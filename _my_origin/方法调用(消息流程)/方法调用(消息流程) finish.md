### 方法的调用其实就只有一种，那就是找到方法地址，处理好方法需要的参数。然后调用方法。最开始的C语言方法的调用就是如此直接，到最后生成可执行文件的时候。所有的你在编译器中调用的方法都直接转化为了该方法的地址。但随着语言的发展。现在的你在编辑器中的方法调用最后并没有直接转化为该方法的地址调用。而是变为了其它方法，然后再寻找原始方法的调用的过程。比如Objective-c中的消息调用，以及函数表调用等。

## 1.消息流程 函数调用
方法的调用通过clang编译成c++文件之后发现类方法和实例方法的调用都转换成了objc_msgSend 而super的调用转化为了objc_msgSenderSuper他们只有第一个参数有差别objc_msgSenderSuper的第一个参数是objc_super结构体指针
![IMAGE](resources/7FF25698E3EE5164D511587F99958205.jpg =481x106)
主要还是讨论objc_msgSend
objc_msgSend的第一个参数是调用方法的对象
第二个参数是selector
剩下的参数就是正常上次方法调用的参数。

1.检查对象是否为空，空直接返回。不为空则获取对象的isa,进入类的方法缓存cache中查找
2.cahce中如果没有找到则进入类的方法列表中查找。这个查找会沿着继承链查找。
3.如果沿着继承链都没有查找到方法则进入动态方法决议,实例方法调用resolveInsntaceMethod,类方法执行resolveClassMethod.可以重写这两个方法通过runtime添加对应的方法。
4.如果没有实现则进入消息转发阶段，调用forwardingTargetForSelector返回的对象就是你要转发给的对象。
5.如果转发的对象不能处理这个消息，则调用methodSignatureForSelector返回一个NSMethodSignature类型的方法签名，然后调用forwardInvocation 会获得一个NSInvocation对象 你可以将它理解为作为对象呈现的objective-c的消息。
6.最后以上都没有实现则抛出unrecognized selector的消息异常。
![IMAGE](resources/29C263C072641D99FD21667E59A22BAE.jpg =709x394)