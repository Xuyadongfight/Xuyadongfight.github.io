## 从线程迁移
有许多方法可以调整现有的线程代码，以利用中央调度和操作对象。尽管在所有情况下都不可能摆脱线程，但在进行切换的地方，性能(以及代码的简单性)可以显著提高。具体来说，使用分派队列和操作队列代替线程有以下几个优点:

* 它减少了应用程序在应用程序的内存空间中存储线程堆栈所付出的内存代价。
* 它消除了创建和配置线程所需的代码。
* 它消除了在线程上管理和调度工作所需的代码。
* 它简化了必须编写的代码。

本章提供了一些关于如何替换现有的基于线程的代码并使用分派队列和操作队列来实现相同类型的行为的技巧和指南。
 
### 用调度队列替换线程
为了理解如何用分派队列替换线程，首先考虑在应用程序中使用线程的一些方式:

* 单个任务线程。创建一个线程来执行单个任务，并在任务完成时释放线程。
* 工作线程。创建一个或多个工作线程，每个线程都有特定的任务。定期向每个线程分派任务。
* 线程池。创建一个通用线程池，并为每个线程设置运行循环。当您有一个任务要执行时，从池中获取一个线程并将任务分派给它。如果没有空闲线程，则将任务排队并等待可用线程。

虽然这些看起来是非常不同的技术，但它们实际上只是同一原理的变体。在每种情况下，都使用一个线程来运行应用程序必须执行的某些任务。它们之间的唯一区别是用于管理线程和任务队列的代码。使用分派队列和操作队列，您可以消除所有线程和线程通信代码，而只关注您想要执行的任务。

如果您正在使用上述线程模型之一，那么您应该已经对应用程序执行的任务类型有了相当好的了解。与其将任务提交给一个自定义线程，不如尝试将该任务封装在操作对象或块对象中，并将其分派到适当的队列。对于不是特别有争议的任务(即不使用锁的任务)，您应该能够进行以下直接替换:

* 对于单个任务线程，将任务封装在块或操作对象中，并将其提交给并发队列。
* 对于工作线程，您需要决定是使用串行队列还是并发队列。如果使用工作线程来同步特定任务集的执行，请使用串行队列。如果您确实使用工作线程执行没有相互依赖关系的任意任务，请使用并发队列。
* 对于线程池，将任务封装在块或操作对象中，并将它们分派到并发队列中执行。

当然，像这样的简单替换可能并不适用于所有情况。如果您正在执行的任务争夺共享资源，理想的解决方案是首先尝试删除或最小化这种争用。如果有方法可以重构或重新架构代码以消除对共享资源的相互依赖，那当然是可取的。但是，如果这样做是不可能的，或者效率可能较低，仍然有一些方法可以利用队列。队列的一大优势是它们提供了一种更可预测的方式来执行代码。这种可预测性意味着仍然有方法可以在不使用锁或其他重量级同步机制的情况下同步代码的执行。你可以使用队列来执行许多相同的任务，而不是使用锁:

* 如果您有必须按特定顺序执行的任务，请将它们提交到串行调度队列。如果您更喜欢使用操作队列，请使用操作对象依赖关系来确保这些对象以特定的顺序执行。
如* 果当前正在使用锁来保护共享资源，请创建一个串行队列来执行修改该资源的任何任务。然后，串行队列将替换现有锁作为同步机制。有关消除锁的更多信息技术，请参见消除基于锁的代码。
* 如果使用线程连接来等待后台任务完成，请考虑使用分派组。您还可以使用NSBlockOperation对象或操作对象依赖项来实现类似的组完成行为。有关如何跟踪正在执行的任务组的详细信息，请参见替换线程连接。
* 如果您使用生产者-消费者算法来管理有限资源池，请考虑将您的实现更改为更改生产者-消费者实现中所示的实现。
* 如果使用线程从描述符读取和写入，或者监视文件操作，请使用调度源中描述的调度源。

重要的是要记住，队列不是替换线程的灵丹妙药。队列提供的异步编程模型适用于延迟不是问题的情况。尽管队列提供了配置队列中任务执行优先级的方法，但更高的执行优先级并不能保证在特定时间执行任务。因此，在需要最小延迟的情况下(例如音频和视频回放)，线程仍然是更合适的选择。
 
### 消除基于锁的代码
对于线程代码，锁是同步访问线程间共享资源的传统方法之一。然而，使用锁是有代价的。即使在无争议的情况下，也总是存在与锁定相关的性能损失。在有争议的情况下，在等待锁释放时，一个或多个线程可能阻塞一段不确定的时间。

用队列替换基于锁的代码可以消除许多与锁相关的问题，还可以简化剩余的代码。您可以创建一个队列来序列化访问该资源的任务，而不是使用锁来保护共享资源。队列不会施加与锁相同的惩罚。例如，将任务排队不需要捕获到内核以获取互斥量。

在对任务排队时，您必须做出的主要决定是同步还是异步。异步提交任务可以让当前线程在执行任务时继续运行。同步提交任务将阻塞当前线程，直到任务完成。这两个选项都有适当的用途，尽管在任何可能的情况下异步提交任务肯定是有利的。

以下部分将向您展示如何用等效的基于队列的代码替换现有的基于锁的代码。
 
### 实现异步锁
异步锁是一种保护共享资源而不阻塞任何修改该资源的代码的方法。当需要修改数据结构作为代码正在执行的其他工作的副作用时，可以使用异步锁。使用传统线程，通常实现这段代码的方式是获取共享资源的锁，进行必要的更改，释放锁，然后继续执行任务的主要部分。但是，使用分派队列，调用代码可以异步地进行修改，而无需等待这些更改完成。

清单5-1显示了一个异步锁实现的示例。在本例中，受保护资源定义了自己的串行调度队列。调用代码向此队列提交一个块对象，该对象包含需要对资源进行的修改。因为队列本身是连续执行块的，所以对资源的更改保证按照它们被接收的顺序进行;但是，因为任务是异步执行的，所以调用线程不会阻塞。
 ```
 dispatch_async(obj->serial_queue, ^{
   // Critical section
});
 ```

### 同步执行临界区
如果当前代码在给定任务完成之前无法继续，则可以使用dispatch_sync函数同步提交任务。该函数将任务添加到调度队列中，然后阻塞当前线程，直到任务执行完毕。调度队列本身可以是串行队列或并发队列，具体取决于您的需要。因为这个函数阻塞当前线程，所以您应该只在必要时使用它。清单5-2展示了使用dispatch_sync包装代码关键部分的技术。
 ```
 dispatch_sync(my_queue, ^{
   // Critical section
});
 ```
 如果您已经在使用串行队列保护共享资源，那么同步调度到该队列并不会比异步调度更能保护共享资源。同步分派的唯一原因是防止当前代码继续运行，直到临界区结束。例如，如果您希望从共享资源中获取一些值并立即使用它，则需要同步分派。如果当前代码不需要等待临界区完成，或者它可以简单地向相同的串行队列提交额外的后续任务，那么异步提交通常是首选。
 
### 循环代码的改进
如果您的代码有循环，并且每次通过循环所做的工作与在其他迭代中所做的工作是独立的，那么您可以考虑使用dispatch_apply或dispatch_apply_f函数重新实现该循环代码。这些函数将循环的每次迭代分别提交给分派队列进行处理。当与并发队列结合使用时，此特性允许您并发地执行循环的多次迭代。

dispatch_apply和dispatch_apply_f函数是同步函数调用，它们会阻塞当前执行线程，直到所有循环迭代完成。当提交给并发队列时，循环迭代的执行顺序不能保证。运行每个迭代的线程都可能阻塞，并导致给定的迭代在它周围的其他迭代之前或之后完成。因此，用于每次循环迭代的块对象或函数必须是可重入的。

清单5-3展示了如何用基于调度的等价语句替换for循环。传递给dispatch_apply或dispatch_apply_f的块或函数必须为表示当前循环迭代的整数值。在本例中，代码只是将当前循环编号打印到控制台。
 ```
 queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(count, queue, ^(size_t i) {
   printf("%u\n", i);
});
 ```
尽管前面的示例很简单，但它演示了使用分派队列替换循环的基本技术。尽管这可能是提高基于循环的代码性能的好方法，但您仍然必须谨慎地使用这种技术。尽管调度队列的开销很低，但在线程上调度每个循环迭代仍然有成本。因此，您应该确保您的循环代码做了足够的工作来保证成本。究竟需要做多少工作是必须使用性能工具来衡量的。

在每个循环迭代中增加工作量的一个简单方法是使用跨步。使用stride，可以重写块代码以执行原始循环的多次迭代。然后按比例减少指定给dispatch_apply函数的计数值。清单5-4展示了如何为清单5-3所示的循环代码实现跨步。在清单5-4中，代码块调用printf语句的次数与stride值相同，在本例中为137。(实际的stride值应该根据代码所做的工作进行配置。)因为在用总迭代次数除以步幅值时还有余数，所以任何剩余的迭代都内联执行。
 ```
 int stride = 137;
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
 
dispatch_apply(count / stride, queue, ^(size_t idx){
    size_t j = idx * stride;
    size_t j_stop = j + stride;
    do {
       printf("%u\n", (unsigned int)j++);
    }while (j < j_stop);
});
 
size_t i;
for (i = count - (count % stride); i < count; i++)
   printf("%u\n", (unsigned int)i);
 ```
使用跨步有一些明确的性能优势。特别是，相对于步幅，当循环迭代的原始数量很高时，步幅提供了好处。并发地调度更少的块意味着执行这些块的代码比调度它们花费更多的时间。但是，与任何性能度量一样，您可能必须使用跨步值来为您的代码找到最有效的值。
 
### 替换线程连接
线程连接允许生成一个或多个线程，然后让当前线程等待这些线程完成。要实现线程连接，父线程将子线程创建为可连接线程。当父线程在没有子线程的结果的情况下无法继续执行时，它将与子线程连接。这个进程阻塞父线程，直到子线程完成它的任务并退出，此时父线程可以从子线程收集结果并继续它自己的工作。如果父线程需要连接多个子线程，它会一次连接一个。

分派组提供了类似于线程连接的语义，但具有一些额外的优点。像线程连接一样，分派组是线程阻塞的一种方式，直到一个或多个子任务执行完毕。与线程连接不同，分派组同时等待它的所有子任务。因为调度组使用调度队列来执行工作，所以它们非常高效。

要使用分派组执行与可接合线程相同的工作，您将执行以下操作:

1. 使用dispatch_group_create函数创建一个新的调度组。
2. 使用dispatch_group_async或dispatch_group_async_f函数将任务添加到组中。提交给组的每个任务都表示通常在可接合线程上执行的工作。
3. 当当前线程无法继续前进时，调用dispatch_group_wait函数来等待该组。该函数阻塞当前线程，直到组中的所有任务执行完毕。

如果使用操作对象实现任务，还可以使用依赖项实现线程连接。您可以将父线程代码移动到操作对象，而不是让父线程等待一个或多个任务完成。然后，您将在父操作对象和任意数量的子操作对象之间建立依赖关系，这些子操作对象被设置来执行通常由可接合线程执行的工作。依赖于其他操作对象可以防止父操作对象在所有操作完成之前执行。

有关如何使用分派组的示例，请参见等待排队任务组。有关在操作对象之间设置依赖项的信息，请参见配置互操作依赖项。
 
### 改变生产者-消费者实现
生产者-消费者模型允许您管理有限数量的动态生成资源。当生产者创建新的资源(或工作)时，一个或多个消费者等待这些资源(或工作)准备好并在它们准备好时消费它们。实现生产者-消费者模型的典型机制是条件或信号量。

使用条件，生产者线程通常执行以下操作:

1. 锁定与条件相关的互斥锁(使用pthread_mutex_lock)。
2. 生产要消耗的资源或工作。
3. 向条件变量发出有东西要消费的信号(使用pthread_cond_signal)
4. 解锁互斥锁(使用pthread_mutex_unlock)。

相应的消费线程依次执行以下操作:

1. 锁定与条件相关的互斥锁(使用pthread_mutex_lock)。
2. 设置一个while循环来执行以下操作:
 * 检查一下是否真的有工作要做。
 * 如果没有工作要做(或者没有可用的资源)，调用pthread_cond_wait来阻塞当前线程，直到出现相应的信号。
3. 获得制作人提供的工作(或资源)。
4. 解锁互斥锁(使用pthread_mutex_unlock)。
5. 处理工作。

使用分派队列，你可以将生产者和消费者实现简化为一个调用:
 ```
 dispatch_async(queue, ^{
   // Process a work item.
});
 ```
当您的生产者有工作要做时，它所要做的就是将该工作添加到队列中，并让队列处理该项。上述代码中唯一更改的部分是队列类型。如果生产者生成的任务需要按特定顺序执行，则使用串行队列。如果生成器生成的任务可以并发执行，则将它们添加到并发队列中，并让系统同时执行尽可能多的任务。
 
### 替换信号量代码
如果当前正在使用信号量限制对共享资源的访问，则应该考虑使用分派信号量。传统的信号量总是需要调用内核来测试信号量。相反，调度信号量在用户空间中快速测试信号量状态，只有在测试失败并且需要阻塞调用线程时才会将信号量捕获到内核中。这种行为导致分派信号量在无争用情况下比传统信号量快得多。不过，在所有其他方面，分派信号量提供了与传统信号量相同的行为。

有关如何使用分派信号量的示例，请参见使用分派信号量来调节有限资源的使用。
 
### 替换运行循环代码
如果使用运行循环来管理在一个或多个线程上执行的工作，您可能会发现队列的实现和维护要简单得多。设置自定义运行循环涉及设置底层线程和运行循环本身。运行循环代码由设置一个或多个运行循环源和编写回调来处理到达这些源的事件组成。您可以简单地创建一个串行队列并将任务分派给它，而不是执行所有这些工作。因此，你可以用一行代码替换你所有的线程和运行循环创建代码:

`dispatch_queue_t myNewRunLoop = dispatch_queue_create("com.苹果。MyQueue ", NULL);`

因为队列自动执行添加到它的任何任务，所以不需要额外的代码来管理队列。您不必创建或配置线程，也不必创建或附加任何运行循环源。此外，只需将任务添加到队列中，就可以在队列上执行新类型的工作。要对运行循环执行相同的操作，您需要修改现有的运行循环源或创建一个新的运行循环源来处理新数据。

运行循环的一种常见配置是处理从网络套接字异步到达的数据。您可以将分派源附加到所需的队列，而不是为这种类型的行为配置运行循环。分派源还提供了比传统运行循环源更多的数据处理选项。除了处理定时器和网口事件外，您还可以使用调度源来读写文件、监视文件系统对象、监视进程和监视信号。您甚至可以定义自定义调度源，并从代码的其他部分异步触发它们。有关设置调度源的详细信息，请参见调度源。

## POSIX线程的兼容性
因为Grand Central Dispatch管理您提供的任务和运行这些任务的线程之间的关系，所以通常应该避免从任务代码调用POSIX线程例程。如果出于某种原因确实需要调用它们，则应该非常小心调用哪些例程。本节将为您提供一个指示，说明从队列任务中调用哪些例程是安全的，哪些是不安全的。这个列表并不完整，但是可以告诉你什么是安全的，什么是不安全的。

一般来说，应用程序不能删除或更改它没有创建的对象或数据结构。因此，使用调度队列执行的块对象不能调用以下函数:
* pthread_detach
* pthread_cancel
* pthread_join
* pthread_kill
* pthread_exit

虽然可以在任务运行时修改线程的状态，但必须在任务返回之前将线程返回到其原始状态。因此，只要将线程返回到原始状态，调用以下函数是安全的:
* pthread_setcancelstate
* pthread_setcanceltype
* pthread_setschedparam
* pthread_sigmask
* pthread_setspecific

用于执行给定块的底层线程可以在不同的调用之间更改。因此，你的应用程序不应该依赖以下函数在调用你的块之间返回可预测的结果:
* pthread_self
* pthread_getschedparam
* pthread_get_stacksize_np
* pthread_get_stackaddr_np
* pthread_mach_thread_np
* pthread_from_mach_thread_np
* pthread_getspecific
 
重要:块必须捕获和抑制在其中抛出的任何语言级异常。在执行块期间发生的其他错误也应该类似地由块处理或用于通知应用程序的其他部分。
 