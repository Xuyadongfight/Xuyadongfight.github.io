## Core Animation
Core Animation是iOS和OS X上的图形渲染和动画的基础，你可以使用它来给视图和应用中的其它可视元素做动画。
![IMAGE](resources/D7A7DAC20D0C2CE4DC2B9212A2A34FD0.jpg =308x214)

### Core Animation管理应用程序的内容
核心动画本身并不是一个绘图系统。它是在硬件中合成和操作应用程序内容的基础设施。这个基础结构的核心是图层对象，你可以使用它来管理和操作内容。图层将你的内容捕获到可以由图形硬件轻松操作的位图中。在大多数应用程序中，图层被用作管理视图内容的一种方式，但你也可以根据自己的需要创建独立的层。
 
### 图层修改触发动画
使用核心动画创建的大多数动画都涉及到图层属性的修改。与视图一样，图层对象也有一个边界矩形、屏幕上的位置、不透明度、变换和许多其他可以修改的面向视觉的属性。对于这些属性中的大多数，改变属性的值会导致创建一个隐式动画，从而使图层从旧值动画到新值。当你想要更多地控制生成的动画行为时，你也可以显式地对这些属性进行动画。
 
### 图层可以组织成层次结构
图层可以分层排列以创建父子关系。图层的排列影响它们以类似于视图的方式管理的视觉内容。附加到视图的一组图层的层次结构反映了相应的视图层次结构。你还可以将独立的图层添加到图层层次结构中，以扩展应用程序的视觉内容，而不仅仅是视图。

### Actions让你改变一个图层的默认行为
隐式层动画是使用动作对象实现的，动作对象是实现预定义接口的通用对象。Core Animation使用动作对象来实现通常与图层相关联的默认动画集。你可以创建自己的动作对象来实现自定义动画，或者使用它们来实现其他类型的行为。然后将动作对象分配给图层的一个属性。当那个属性改变时，Core Animation会检索你的动作对象并告诉它执行它的动作。
 
## 核心动画的基础
Core Animation为应用程序的视图和其他视觉元素提供了一个通用的动画系统。Core Animation不能替代应用程序的视图。相反，它是一种与视图集成的技术，以提供更好的性能和对其内容动画化的支持。它通过将视图的内容缓存到可由图形硬件直接操作的位图中来实现这种行为。在某些情况下，这种缓存行为可能需要你重新考虑如何呈现和管理应用程序的内容，但大多数情况下，你使用Core Animation时根本不知道它在那里。除了缓存视图内容外，Core Animation还定义了一种方法来指定任意的视觉内容，将该内容与视图集成，并将其与其他内容一起动画化。
你使用Core Animation来对应用程序的视图和可视对象进行动画化修改。大多数更改与修改可视对象的属性有关。例如，你可以使用核心动画来改变视图的位置、大小或不透明度。当进行这样的更改时，核心动画在属性的当前值和您指定的新值之间动画。你通常不会使用Core Animation每秒60次替换视图的内容，例如在卡通中。相反，你可以使用Core Animation在屏幕上移动视图的内容，将内容淡入或淡出，对视图应用任意图形转换，或更改视图的其他视觉属性。
 
### 图层为绘图和动画提供了基础
图层对象是在3D空间中组织的2D表面，是使用核心动画所做的一切的核心。与视图一样，图层管理有关其表面的几何形状、内容和视觉属性的信息。与视图不同，图层不定义自己的外观。图层仅仅管理位图周围的状态信息。位图本身可以是视图绘制本身的结果，也可以是你指定的固定图像。出于这个原因，你在应用程序中使用的主要图层被认为是模型对象，因为它们主要管理数据。记住这个概念很重要，因为它会影响动画的行为。

#### 基于图层的绘图模型
大多数图层在你的应用程序中不做任何实际的绘图。相反，一个图层捕获你的应用程序提供的内容并将其缓存在一个位图中，这有时被称为后台存储。当你随后更改图层的属性时，你所做的只是更改与图层对象相关的状态信息。当一个变化触发一个动画时，核心动画将图层的位图和状态信息传递给图形硬件，它使用新的信息渲染位图。因为它操作静态位图，所以基于图层的绘图与更传统的基于视图的绘图技术有很大的不同。对于基于视图的绘图，对视图本身的更改通常会导致调用视图的drawRect:方法来使用新参数重新绘制内容。但是以这种方式绘制是昂贵的，因为它是使用主线程上的CPU完成的。Core Animation 通过尽可能操纵硬件中的缓存位图来实现相同或类似的效果，从而避免了这种开销。尽管Core Animation 尽可能多地使用缓存内容，但你的应用仍然必须提供初始内容并不时更新。
 
#### 图层的动画
图层对象的数据和状态信息与该层内容在屏幕上的可视化表示解耦。这种解耦给Core Animation 提供了一种方法来干预自己，并将从旧状态值到新状态值的变化动画化。例如，改变图层的位置属性会导致核心动画将图层从当前位置移动到新指定的位置。对其他属性的类似更改会产生适当的动画。在动画过程中，Core animation 会在硬件中为你完成所有逐帧绘制。你所要做的就是指定动画的开始和结束点，然后让Core animation 完成其余的工作。你还可以根据需要指定自定义定时信息和动画参数;然而，核心动画提供合适的默认值，如果你不这样做。

### 图层对象定义自己的几何形状
图层的工作之一是管理其内容的视觉几何形状。视觉几何包含有关该内容的边界、其在屏幕上的位置以及该层是否已以任何方式旋转、缩放或转换的信息。与视图一样，图层也有框架和边界矩形，你可以使用它们来定位图层及其内容。图层还具有视图所没有的其他属性，例如锚点，锚点定义了操作发生的点。指定图层几何的某些方面的方式也不同于为视图指定这些信息的方式。

#### 图层使用两种坐标系统
图层使用基于点的坐标系统和单位坐标系统来指定内容的位置。使用哪个坐标系统取决于所传递信息的类型。当指定直接映射到屏幕坐标或必须相对于另一图层指定的值时，例如图层的位置属性，使用基于点的坐标。当值不应该绑定到屏幕坐标，因为它是相对于其他一些值时，使用单位坐标。例如，图层的anchorPoint属性指定了一个相对于层本身边界的点，这个点可以改变。
基于点的坐标最常见的用途之一是指定图层的大小和位置，这可以使用图层的边界和位置属性来实现。边界定义了图层本身的坐标系统，并包含了图层在屏幕上的大小。position属性定义了图层相对于其父图层的坐标系统的位置。虽然图层有一个frame属性，但该属性实际上是从边界和位置属性中的值派生出来的，使用频率较低。
图层的边界和框架矩形的方向总是与底层平台的默认方向相匹配。
需要注意的一点是position属性位于图层的中间。该属性是其定义根据图层的anchorPoint属性中的值而更改的几个属性之一。锚点表示某些坐标的起始点，在锚点影响几何操作中有更详细的描述。
锚点是使用单位坐标系指定的几个属性之一。核心动画使用单位坐标来表示属性，当图层的大小改变时，这些属性的值可能会改变。你可以将单位坐标视为指定总可能值的百分比。单位坐标空间中的每个坐标都有0.0到1.0的范围。例如，沿着x轴，左边缘位于坐标0.0，右边缘位于坐标1.0。在y轴上，单位坐标值的方向随平台的不同而变化。
所有的坐标值，无论是点还是单位坐标，都被指定为浮点数。使用浮点数可以指定可能位于正常坐标值之间的精确位置。使用浮点值很方便，特别是在打印或绘制到视网膜显示器时，其中一个点可能由多个像素表示。浮点值允许您忽略底层设备分辨率，只指定所需精度的值。
 
#### 锚点影响几何操作
图层的几何相关操作相对于图层的锚点发生，你可以使用图层的anchorPoint属性访问该锚点。当操纵图层的位置或变换属性时，锚点的影响是最明显的。position属性总是相对于图层的锚点指定，并且应用于图层的任何转换也相对于锚点发生。

#### 图层可以在三维操作
每个图层都有两个变换矩阵，可以使用它们来操作层及其内容。CALayer的transform属性指定你想要应用于层及其嵌入子层的转换。通常，当你想修改图层本身时，你会使用这个属性。例如，你可以使用该属性缩放或旋转图层或临时更改其位置。sublayerTransform属性定义了只应用于子图层的附加转换，并且最常用于向场景内容添加透视视觉效果。
变换通过将坐标值与数字矩阵相乘来获得表示原始点的变换版本的新坐标。因为核心动画值可以在三维空间中指定，所以每个坐标点都有四个值，这些值必须通过一个4乘4的矩阵相乘，在核心动画中，图形中的变换由CATransform3D类型表示。幸运的是，你不必直接修改此结构的字段来执行标准转换。Core Animation提供了一套全面的功能，用于创建缩放、平移和旋转矩阵以及进行矩阵比较。除了使用函数操作转换之外，Core Animation还扩展了键值编码支持，允许你使用键值路径修改转换。
 
#### 图层树反映了动画状态的不同方面
使用核心动画的应用程序有三组图层对象。每一组图层对象都有不同的作用，使你的应用程序的内容出现在屏幕上:
* 模型层树(或简称“图层树”)中的对象是应用程序与之交互最多的对象。该树中的对象是模型对象，用于存储任何动画的目标值。当你改变这个层的属性时，你使用这些对象之一。
* 呈现（表示）树中的对象包含任何正在运行的动画的动态值。图层树对象包含动画的目标值，而表示树中的对象在屏幕上显示时反映当前值。永远不要修改此树中的对象。相反，你可以使用这些对象来读取当前的动画值，或者从这些值开始创建一个新的动画。
* 渲染树中的对象执行实际的动画，并且是Core Animation私有的。

每一组图层对象都被组织成一个层次结构，就像你应用程序中的视图一样。事实上，对于一个应用程序，为它的所有视图启用图层，每个树的初始结构与视图层次结构完全匹配。但是，应用程序可以根据需要在层层次结构中添加额外的图层对象(即与视图不关联的层)。在不需要视图的所有开销的情况下，你可以这样做来优化应用程序的内容性能。
对于图层树中的每个对象，在呈现树和渲染树中都有一个匹配的对象。应用程序主要处理图层树中的对象，但有时也会访问表示树中的对象。具体来说，访问图层树中对象的presentationLayer属性将返回表示树中相应的对象。你可能想要访问那个对象来读取动画中间属性的当前值。

### 图层和视图之间的关系
图层不是应用程序视图的替代品——也就是说，你不能仅仅基于图层对象创建一个可视界面。图层为视图提供基础结构。具体来说，图层使绘制和动画视图的内容更容易，更有效，并在这样做时保持高帧率。然而，有很多事情是图层不能做的。图层不处理事件、绘制内容、参与响应链或做许多其他事情。出于这个原因，每个应用程序仍然必须有一个或多个视图来处理这些类型的交互。
在iOS中，每个视图都有相应的图层对象支持，但在OS X中，你必须决定哪些视图应该有图层。在OS X v10.8和更高版本中，为所有视图添加图层可能是有意义的。但是，你不需要这样做，并且在开销不合理和不需要的情况下仍然可以禁用图层。图层确实会增加应用程序的内存开销，但它们的好处往往大于坏处，所以最好在禁用图层支持之前测试应用程序的性能。

**注意:对于图层支持视图，建议尽可能操作视图，而不是其图层。在iOS中，视图只是图层对象的浅包装，所以你对图层所做的任何操作通常都很好。但在iOS和OS X中，操作图层而不是视图可能无法产生预期的结果。只要有可能，本文就会指出这些缺陷，并尝试提供帮助你解决这些问题的方法。**
 
除了与视图关联的图层之外，你还可以创建没有相应视图的图层对象。你可以将这些独立的图层对象嵌入到应用程序中的任何其他图层对象中，包括那些与视图相关的图层对象。通常使用独立图层对象作为特定优化路径的一部分。例如，如果你想在多个地方使用相同的图像，你可以加载图像一次，并将其与多个独立的图层对象相关联，并将这些对象添加到图层树中。然后，每个图层都引用源图像，而不是试图在内存中创建该图像的自己的副本。

 
### 不同的图层类提供专属的功能
#### CAEmitterLayer
用于实现基于核心动画的粒子发射器系统。发射器层对象控制粒子的产生和它们的起源。

#### CAGradientLayer
用于绘制填充图层形状的颜色渐变(在任何圆角的范围内)。

#### CAMetalLayer
用于设置和出售可绘制纹理的渲染层内容使用Metal

#### CAEAGLLayer/CAOpenGLLayer
用于使用OpenGL ES (iOS)或OpenGL (OS X)为渲染层内容设置后台存储和上下文。

#### CAReplicatorLayer
当你想要自动复制一个或多个子容器时使用。复制器为你制作副本，并使用你指定的属性来更改副本的外观或属性。
 
#### CAScrollLayer
用于管理由多个子层组成的大型可滚动区域。
 
#### CAShapeLayer
用于绘制三次贝塞尔样条曲线。形状图层对于绘制基于路径的形状是有利的，因为它们总是产生清晰的路径，而不是绘制到图层的后备存储中的路径，后者在缩放时看起来不那么好。然而，清晰的结果确实涉及到在主线程上渲染形状并缓存结果。
 
#### CATextLayer
用于呈现纯文本字符串或带有属性的文本字符串。
 
#### CATiledLayer
用于管理大图像，该图像可以分成较小的块并单独呈现，支持放大和缩小内容。

#### CATransformLayer
用于渲染真正的3D层层次结构，而不是由其他层类实现的扁平层层次结构。
 
### 提供一个图层的内容
图层是管理应用程序提供的内容的数据对象。图层的内容由包含你想要显示的可视化数据的位图组成。你可以通过以下三种方式之一为该位图提供内容:
* 将图像对象直接分配给图层对象的contents属性。(这种技术最适用于从未或很少改变的图层内容。)
* 给图层分配一个委托对象，让委托绘制图层的内容。(这种技术最适用于可能周期性变化的层内容，并且可以由外部对象(如视图)提供。)
* 定义一个图层子类并覆盖它的一个绘图方法来提供自己的图层内容。(如果你必须创建一个自定义图层子类，或者如果你想改变图层的基本绘图行为，这种技术是合适的。)

唯一需要担心为图层提供内容的时候是你自己创建图层对象的时候。如果你的应用程序只包含图层支持视图，你不必担心使用任何前面的技术来提供层内容。图层支持的视图以最有效的方式自动为其相关图层提供内容。
 
#### 使用图像作为图层的内容
因为图层只是一个管理位图图像的容器，所以你可以将图像直接分配给图层的contents属性。将图像分配给图层很容易，并允许你指定要在屏幕上显示的确切图像。该层使用你直接提供的图像对象，而不尝试创建该图像的自己的副本。在应用程序在多个地方使用相同图像的情况下，这种行为可以节省内存。
你分配给图层的图像必须是CGImageRef类型。在分配图像时，请记住提供一个分辨率与本机设备的分辨率匹配的图像。对于带有Retina显示器的设备，这可能还需要你调整图像的contentsScale属性。
 
#### 使用委托来提供图层的内容
如果图层的内容动态变化，可以使用委托对象在需要时提供和更新该内容。在显示时，该图层调用委托的方法来提供所需的内容:
* 如果你的委托实现了displayLayer:方法，该实现负责创建位图并将其分配给图层的contents属性。

* 如果你的委托实现了drawLayer:inContext:方法，Core Animation 会创建一个位图，创建一个图形上下文来绘制那个位图，然后调用你的委托方法来填充这个位图。委托方法所要做的就是绘制到提供的图形上下文中。

委托对象必须实现displayLayer:或drawLayer:inContext:方法。如果委托同时实现了displayLayer:和drawLayer:inContext:方法，则图层只调用displayLayer:方法。

重写displayLayer:方法最适合应用程序喜欢加载或创建它想要显示的位图的情况。
 
**注意：对于有图层支持的视图，比如UIView。有图层支持的视图会自动使其成为图层的委托，并实现所需的委托方法，你不应该更改这个配置，相反，你应该实现视图的drawRect:方法来绘制内容。**

#### 通过子类化提供图层内容
如果你正在实现一个自定义的图层类，你可以覆盖你的图层类的绘制方法来做任何绘制。图层对象本身生成自定义内容是不常见的，但图层肯定可以管理内容的显示。例如，CATiledLayer类通过将大图像分解成可以单独管理和渲染的小图像来管理大图像。因为只有图层拥有在任何给定时间需要渲染哪些贴图的信息，所以它直接管理绘图行为。

当子类化时，你可以使用以下两种技术来绘制你的图层内容:

* 覆盖图层的dispaly方法，并使用它直接设置图层的contents属性。
* 覆盖图层的drawInContext:方法，并使用它来绘制提供的图形上下文。

覆盖哪个方法取决于你需要对绘图过程的控制程度。display方法是更新图层内容的主要入口点，因此重写该方法将使你完全控制该过程。重写显示方法还意味着你负责创建分配给contents属性的CGImageRef。如果你只是想绘制内容(或者让你的图层管理绘制操作)，你可以重写drawInContext:方法，让图层为你创建后备存储。
 
### 调整你提供的内容
当你将一个图像分配给一个图层的contents属性时，该图层的contentsGravity属性决定了如何操纵该图像以适应当前的边界。默认情况下，如果图像大于或小于当前边界，则图层对象将缩放图像以适应可用空间。如果图层边界的宽高比与图像的宽高比不同，则可能导致图像失真。你可以使用contentsGravity属性来确保你的内容以最好的方式呈现。

你可以分配给contentsGravity属性的值分为两类:

* 基于位置的重力常数允许你将图像固定在图层边界矩形的特定边缘或角落上，而无需缩放图像。
* 基于缩放的重力常数允许你使用几种选项之一来拉伸图像，其中一些选项保留长宽比，而另一些则不保留。

图2-1显示了基于位置的重力设置如何影响图像。除了kCAGravityCenter常量外，每个常量都将图像固定在图层边界矩形的特定边缘或角落上。kCAGravityCenter常数使图层中的图像居中。这些常量都不会导致图像以任何方式缩放，因此图像总是以其原始大小呈现。如果图像比图层的边界大，这可能会导致图像的部分被剪切，如果图像较小，则未被图像覆盖的图层部分显示图层的背景颜色(如果设置)。
![IMAGE](resources/4770F9C01F79F81138B5E0C663787211.jpg =716x383)

图2-2显示了基于比例的重力常数如何影响你的图像。如果图像不完全适合图层的边界矩形，那么所有这些常数都会对图像进行缩放。模式之间的区别在于它们如何处理图像的原始宽高比。一些模式保留了它，而另一些则没有。默认情况下，图层的contentsGravity属性被设置为kCAGravityResize常量，这是唯一不保留图像长宽比的模式。
![IMAGE](resources/6C13CA9BBE65F62ECFC93357BCAF4D11.jpg =652x303)

#### 处理高分辨率图像
图层没有底层设备屏幕分辨率的任何固有知识。图层只是存储指向位图的指针，并在给定可用像素的情况下以最佳方式显示它。如果你将一个图像分配给一个图层的contents属性，你必须通过将图层的contentsScale属性设置为适当的值来告诉Core Animation 图像的分辨率。该属性的默认值是1.0，它适用于要在标准分辨率屏幕上显示的图像。如果你的图像打算用于Retina显示，请将此属性的值设置为2.0。建议动态获取图像分辨率赋值。`[UIScreen mainScreen].scale`
改变contentsScale属性的值只有在你直接给图层分配位图时才有必要。UIKit和AppKit中的层支持视图根据屏幕分辨率和视图管理的内容自动将其层的比例因子设置为适当的值。例如，如果你在OS X 中将一个NSImage对象分配给一个图层的contents属性，AppKit会查看该图像是否有标准和高分辨率的变体。如果有，AppKit使用当前分辨率的正确变体，并设置contentsScale属性的值来匹配。

### 调整图层的视觉样式和外观
图层对象内置了视觉装饰，比如边框和背景色，你可以用它们来补充图层的主要内容。由于这些视觉装饰不需要你进行任何渲染，因此在某些情况下可以将图层用作独立实体。你所要做的就是在图层上设置一个属性，然后图层处理必要的绘图，包括任何动画。
 
#### 图层有自己的背景和边框
除了基于图像的内容外，图层还可以显示填充的背景和描边。背景颜色呈现在图层内容图像的后面，边框呈现在该图像的顶部，如图2-3所示。如果图层包含子图层，它们也会出现在边框下方。因为背景色位于图像的后面，所以这种颜色可以穿透图像的任何透明部分。
![IMAGE](resources/886C87FD672E67769D109AEF890902A0.jpg =531x323)

**注意:你可以使用任何类型的颜色作为图层的背景，包括具有透明度或使用图案图像的颜色。当使用模式图像时，请注意Core Graphics 处理模式图像的渲染，并使用其标准坐标系统，这与iOS中的默认坐标系统不同。因此，在iOS上渲染的图像默认情况下是颠倒的，除非你翻转坐标。**

如果你将图层的背景色设置为不透明的颜色，考虑将图层的不透明属性设置为YES。这样做可以提高在屏幕上合成层时的性能，并消除层的后台存储来管理alpha通道的需要。但是，如果一个图层也具有非零角半径，则不能将其标记为不透明。

#### 图层支持角半径
你可以通过给你的图层添加一个角半径来创建一个圆角矩形效果。角半径是一种视觉装饰，它掩盖了图层边界矩形的部分角，以允许底层内容显示出来，如图2-4所示。因为它涉及到应用透明蒙版，所以角半径不会影响图层内容属性中的图像，除非将masksToBounds属性设置为YES。然而，角的半径总是影响图层的背景颜色和边框的绘制方式。
![IMAGE](resources/6AC87B0FEA8CDBE07A09E01E6488AA25.jpg =602x406)

#### 图层支持内置阴影
CALayer类包含几个用于配置阴影效果的属性。阴影通过使图层看起来好像漂浮在底层内容之上来增加图层的深度。这是另一种视觉装饰，你可能会发现它在特定情况下对你的应用程序很有用。通过图层，你可以控制阴影的颜色，相对于图层内容的位置，不透明度和形状。

图层阴影的不透明度值默认设置为0，这有效地隐藏了阴影。将不透明度更改为非零值将导致核心动画绘制阴影。因为默认情况下阴影直接位于图层下方，所以你可能还需要在看到阴影之前更改阴影的偏移量。重要的是要记住，你为阴影指定的偏移量是使用图层的本地坐标系统来应用的，这在iOS和OS x上是不同的。图2-5显示了一个阴影向下延伸到图层右侧的图层。在iOS中，这需要为y轴指定一个正值，但在OS X中，该值需要为负值。
![IMAGE](resources/6FA33B7C39F035D83B0111391EE34C18.jpg =478x260)

当添加阴影到一个图层时，阴影是该图层内容的一部分，但实际上扩展到该图层边界矩形之外。因此，如果你为图层启用了masksToBounds属性，阴影效果就会在边缘被剪裁。如果你的图层包含任何透明内容，这可能会导致一个奇怪的效果，即直接在你的图层下面的阴影部分仍然可见，但延伸到你的图层之外的部分则不可见。如果你想要一个阴影，但也想使用边界遮罩，你使用两层而不是一个。将蒙版应用到包含内容的图层上，然后将该图层嵌入到第二个大小相同的图层中，该图层启用阴影效果。

### 给图层添加自定义属性
CAAnimation和CALayer类扩展了键值编码约定以支持自定义属性。你可以使用此行为将数据添加到层中，并使用你定义的自定义键检索数据。你甚至可以将动作与自定义属性关联起来，这样当你更改属性时，就会执行相应的动画。
```
- (void)touchesBegan:(NSSet<UITouch *> *)touches withEvent:(UIEvent *)event{
    NSString *mykey = @"testkey";
    [self.view.layer setValue:@10 forKey:mykey];
    id temp = [self.view.layer valueForKey:mykey];
    NSLog(@"%@",temp);
}
```

## 动画化图层内容
Core Animation提供的基础架构可以很容易地为应用程序的图层创建复杂的动画，并扩展到拥有这些图层的任何视图。

### 动画简单的改变一个图层的属性
你可以根据需要隐式或显式地执行简单的动画。隐式动画使用默认的计时和动画属性来执行动画，而显式动画需要你自己使用动画对象来配置这些属性。因此，隐式动画非常适合你想要在没有大量代码的情况下进行更改的情况，并且默认计时非常适合你。
简单的动画包括改变图层的属性，并让核心动画随着时间的推移为这些变化制作动画。图层定义了许多影响图层可见外观的属性。改变这些属性之一是一种动画化外观变化的方法。例如，将图层的不透明度从1.0更改为0.0会导致图层逐渐淡出并变得透明。

**重要提示:虽然你有时可以直接使用核心动画界面为图层支持的视图制作动画，但这样做通常需要额外的步骤。有关如何将核心动画与图层支持视图结合使用的更多信息，请参阅如何为图层支持视图制作动画。**

要触发隐式动画，你所要做的就是更新图层对象的属性。当修改图层树中的图层对象时，这些对象会立即反映你的更改。但是，图层对象的视觉外观不会立即改变。相反，Core Animation 使用你的更改作为触发器来创建和调度一个或多个隐式动画执行。
要使用动画对象显式地进行相同的更改，请创建一个CABasicAnimation对象并使用该对象来配置动画参数。在将动画添加到图层之前，你可以设置动画的开始和结束值，更改持续时间或更改任何其他动画参数。清单3-2展示了如何使用动画对象淡出一个图层。在创建对象时，为要动画的属性指定关键路径，然后设置动画参数。要执行动画，你可以使用addAnimation:forKey:方法将其添加到你想要动画的图层中。
![IMAGE](resources/099E455A65AB410437AF788C0D1E72BD.jpg =709x237)
 
**提示:当创建显式动画时，建议始终为动画对象的fromValue属性分配一个值。如果你没有为这个属性指定一个值，Core animation 将使用图层的当前值作为起始值。如果你已经将属性更新为其最终值，则可能不会产生你想要的结果。**

与更新层对象数据值的隐式动画不同，显式动画不会修改图层树中的数据。显式动画只产生动画。在动画结束时，Core animation 从图层中移除动画对象，并使用其当前数据值重新绘制图层。如果你想让一个显式动画的改变是永久的，你必须像前面的例子一样更新图层的属性。
隐式和显式动画通常在当前运行循环结束后开始执行，并且当前线程必须有一个运行循环才能执行动画。如果你改变了多个属性，或者如果你在一个图层中添加了多个动画对象，所有这些属性的改变都会同时被动画化。例如，你可以通过同时配置两个动画，在将图层移出屏幕时使其褪色。然而，你也可以配置动画对象在一个特定的时间开始。
 
### 使用关键帧动画来改变图层属性
基于属性的动画将属性从起始值更改为结束值，而CAKeyframeAnimation对象允许你通过一组目标值进行动画，这种方式可能是线性的，也可能不是线性的。关键帧动画由一组目标数据值和每个值应该到达的时间组成。在最简单的配置中，使用数组指定值和时间。对于图层位置的更改，你也可以让更改遵循路径。动画对象接受你指定的关键帧，并通过在给定时间段内从一个值插值到下一个值来构建动画。
![IMAGE](resources/BD48A8895103189D1A897E0FE04E638D.jpg =1003x508)
 
#### 指定关键帧值
关键帧值是关键帧动画中最重要的部分。这些值定义了动画在执行过程中的行为。指定关键帧值的主要方法是作为对象数组，但是对于包含CGPoint数据类型的值(例如层的anchorPoint和position属性)，你可以指定CGPathRef数据类型。

在指定值数组时，将什么放入数组取决于属性所需的数据类型。你可以直接向数组中添加一些对象;但是，某些对象必须在添加之前强制转换为id，并且所有标量类型或结构都必须由对象包装。例如:

* 对于以CGRect为参数的属性(比如bounds和frame属性)，将每个矩形包装在NSValue对象中。
* 对于图层的transform属性，将每个CATransform3D矩阵包装在一个NSValue对象中。将此属性动画化会导致关键帧动画依次将每个变换矩阵应用于图层。
* 对于borderColor属性，在将每个CGColorRef数据类型添加到数组之前，将其转换为类型id。
* 对于接受CGFloat值的属性，在将其添加到数组之前，将每个值包装在NSNumber对象中。
* 当动画层的内容属性时，指定一个CGImageRef数据类型数组。

对于采用CGPoint数据类型的属性，你可以创建一个点数组(包装在NSValue对象中)，或者你可以使用CGPathRef对象来指定要遵循的路径。当你指定一个点数组时，关键帧动画对象在每个连续点之间绘制一条直线，并沿着该路径运行。当你指定CGPathRef对象时，动画从路径的起点开始，并沿着其轮廓，包括沿着任何曲面。你可以使用开放或封闭路径。
 
#### 指定关键帧动画的计时
关键帧动画的时间和节奏比基本动画要复杂得多，你可以使用几个属性来控制它:

* calculationMode属性定义了用于计算动画计时的算法。此属性的值会影响其他与时间相关的属性的使用方式。
1. 线性动画和立方动画——也就是将calculationMode属性设置为kCAAnimationLinear或kcaanimationcubic的动画——使用提供的定时信息来生成动画。这些模式给你最大的控制动画时间。
2. 有节奏的动画——也就是将calculationMode属性设置为kcaanimationpace或kcaanimationcubicpace的动画——不依赖于keyTimes或timingFunctions属性提供的外部计时值。相反，计时值是隐式计算的，以提供恒定速度的动画。
3. 离散动画——也就是将calculationMode属性设置为kcaanimationdiscrete的动画——会导致动画属性从一个关键帧值跳转到下一个关键帧值，而不需要任何插值。这种计算模式使用keyTimes属性中的值，但忽略timingFunctions属性

* keyTimes属性指定应用每个关键帧值的时间标记。此属性仅在计算模式设置为kCAAnimationLinear, kCAAnimationDiscrete或kCAAnimationCubic时使用。它不用于节奏动画。
* timingFunctions属性指定每个关键帧段使用的计时曲线。(这个属性取代了继承的timingFunction属性。)

如果你想自己处理动画计时，使用kCAAnimationLinear或kCAAnimationCubic模式和keyTimes和timingFunctions属性。keyTimes定义应用每个关键帧值的时间点。所有中间值的定时是由定时函数控制的，它允许你对每个部分应用缓和入或缓和出曲线。如果不指定任何定时函数，则时序为线性。
 
### 停止一个正在运行的显式动画
动画通常会一直运行到完成，但如果需要，你可以使用以下技术之一提前停止它们:

* 要从图层中移除单个动画对象，请调用图层的removeAnimationForKey:方法来移除动画对象。这个方法使用传递给addAnimation:forKey:方法的键来识别动画。指定的键不能为nil。
* 要从图层中移除所有动画对象，调用图层的removeAllAnimations方法。此方法立即删除所有正在进行的动画，并使用其当前状态信息重新绘制图层。

**注意:不能直接从图层中删除隐式动画。**

当你从一个图层中删除一个动画时，核心动画会使用当前值重新绘制该图层。因为当前值通常是动画的结束值，这可能会导致图层的外观突然跳跃。如果你希望图层的外观保持在动画最后一帧的位置，你可以使用表示树中的对象来检索这些最终值，并将它们设置在图层树中的对象上。

### 动画多个变化一起
如果你想同时在一个图层对象上应用多个动画，你可以使用CAAnimationGroup对象将它们组合在一起。使用组对象通过提供单个配置点简化了多个动画对象的管理。应用于组的计时和持续时间值覆盖单个动画对象中的相同值。
清单3-4展示了如何使用一个动画组同时以相同的持续时间执行两个与边框相关的动画。
![IMAGE](resources/FC5E57198532CEC94E25BE3EA2D71D32.jpg =1013x510)

### 检测动画的结束
Core Animation提供了检测动画何时开始或结束的支持。这些通知是执行与动画相关的家务任务的好时机。例如，你可以使用开始通知来设置一些相关的状态信息，并使用相应的结束通知来取消该状态。
有两种不同的方式来通知动画的状态:
* 使用setCompletionBlock:方法向当前事务添加一个完成块。当事务中的所有动画完成时，事务执行你的完成块。
* 给CAAnimation对象分配一个委托，并实现animationDidStart:和animationDidStop:finished:委托方法。

如果你想把两个动画链接在一起，这样一个动画在另一个动画结束时开始，不要使用动画通知。相反，使用你的动画对象的beginTime属性在期望的时间开始每一个。要将两个动画链接在一起，请将第二个动画的开始时间设置为第一个动画的结束时间。
 
### 如何动画图层支持视图
如果一个图层属于图层支持视图，建议使用UIKit或AppKit提供的基于视图的动画界面来创建动画。有一些方法可以直接使用核心动画界面来动画层，但如何创建这些动画取决于目标平台。
 
#### iOS中修改图层的规则
因为iOS视图总是有一个图层，UIView类本身直接从图层对象中获取它的大部分数据。因此，你对图层所做的更改也会自动反映到视图对象中。这个行为意味着你可以使用Core Animation或者UIView接口来做你的改变。
如果你想使用Core Animation类来初始化动画，你必须在基于视图的动画块中发出所有Core Animation 调用。UIView类默认禁用图层动画，但在动画块中重新启用它们。因此，在动画块之外所做的任何更改都不是动画。清单3-5展示了一个如何隐式改变图层不透明度和显式改变图层位置的例子。在这个例子中，myNewPosition变量是预先计算的，并被块捕获。两个动画同时开始，但不透明度动画以默认时间运行，而位置动画以其动画对象中指定的时间运行。
![IMAGE](resources/B4736789B8CB60311A47608046DE8E1E.jpg =743x314)

### 记得更新视图约束作为你动画的一部分
如果你正在使用基于约束的布局规则来管理视图的位置，那么在配置动画时，必须删除任何可能干扰动画的约束。约束会影响你对视图的位置或大小所做的任何更改。它们还会影响视图与其子视图之间的关系。如果你正在对这些项中的任何项进行动画更改，则可以删除约束，进行更改，然后应用所需的任何新约束。


## 构建图层层次结构
大多数时候，在应用程序中使用图层的最佳方法是将它们与视图对象结合使用。但是，有时你可能需要通过向其添加额外的图层对象来增强视图层次结构。当这样做可以提供更好的性能或让你实现难以单独使用视图实现的功能时，你可能会使用图层。在这些情况下，你需要知道如何管理你创建的图层层次结构。

### 将图层排列成图层层次结构
图层层次结构在许多方面与视图层次结构相似。你将一个图层嵌入另一个图层，以在被嵌入的图层(称为子层)和父图层(称为超层)之间创建父-子关系。这种亲子关系影响子图层的各个方面。例如，它的内容位于父元素的内容之上，它的位置是相对于父元素的坐标系统指定的，并且它会受到应用于父元素的任何转换的影响。
#### 添加，插入和删除子层
每个层对象都有添加、插入和删除子层的方法。表4-1总结了这些方法及其行为。
![IMAGE](resources/C183ED24B3E89509119D9BF443980694.jpg =1185x291)
在处理自己创建的图层对象时，可以使用前面的方法。你不能使用这些方法来排列属于图层支持的视图的图层。但是，图层支持视图可以充当你自己创建的独立层的父层。
 
#### 定位和调整子图层大小
在添加和插入子图层时，必须在子图层显示在屏幕上之前设置其大小和位置。你可以在将子图层添加到你的图层层次结构后修改它的大小和位置，但应该在创建图层时习惯设置这些值。
你可以使用bounds属性设置子图层的大小，并使用position属性设置其在超层中的位置。边界矩形的原点几乎总是(0,0)，大小是你想要的以点为单位指定的图层的大小。position属性中的值是相对于图层的锚点来解释的，锚点默认位于图层的中心。如果你不给这些属性赋值，Core Animation将图层的初始宽度和高度设置为0，并将位置设置为(0,0)。
** 重要提示:对图层始终使用整数的宽度和高度。**

### 图层层次结构如何影响动画
一些超层属性可以影响应用于其子图层的任何动画的行为。其中一个属性是速度属性，它是动画速度的乘数。此属性的值默认设置为1.0，但将其更改为2.0会导致动画以两倍于原始速度运行，从而在一半的时间内完成。此属性不仅影响其设置的图层，还影响该层的子图层。这样的变化也是成倍的。如果子图层及其超层的速度都为2.0，则子图层上的动画以其原始速度的四倍运行。
大多数其他图层的变化以可预测的方式影响任何包含的子图层。例如，对一个图层应用旋转变换，旋转该图层及其所有子层。同样，改变一个图层的不透明度也会改变其子图层的不透明度。

### 调整图层层次结构的布局
核心动画支持几个选项来调整子层的大小和位置，以响应其超层的变化。在iOS中，图层支持视图的广泛使用使得图层层次结构的创建变得不那么重要;只支持手动布局更新。对于OS X，还有其他几个选项可以让你更容易地管理层次结构。
图层级布局只有在使用你创建的独立图层对象构建图层层次结构时才有意义。如果你的应用程序的图层都与视图相关联，使用基于视图的布局支持来更新视图的大小和位置以响应变化。

### 手动布局你的图层层次结构
在iOS和OS X上，你可以通过在上层的委托对象上实现layoutSublayersOfLayer:方法来手动处理布局。你可以使用该方法来调整当前嵌入层内的任何子层的大小和位置。在进行手动布局更新时，由你执行必要的计算来定位每个子层。
如果你正在实现一个自定义图层子类，你的子类可以覆盖layoutSublayers方法，并使用该方法(而不是委托)来处理任何布局任务。只有在需要完全控制自定义图层类中子层的位置时，才应该重写此方法。替换默认实现可以防止核心动画在OS X 上应用约束或自动调整大小规则。

### 子图层和剪切
与视图不同，超层不会自动裁剪位于其边界矩形之外的子层的内容。相反，在默认情况下，超层允许其子层完整地显示。然而，你可以通过将图层的masksToBounds属性设置为YES来重新启用剪切。
图层的剪切蒙版形状包括图层的角半径(如果指定了角半径)。图4-3展示了一个图层，它演示了masksToBounds属性是如何影响圆角图层的。当属性设置为NO时，子层将完整地显示，即使它们超出了父层的边界。将属性更改为YES会导致它们的内容被剪切。
![IMAGE](resources/75B20C3289A46AD56FB5333A35B8F341.jpg =561x420)

### 转换图层之间的坐标值
有时，你可能需要将一个图层中的坐标值转换为另一图层中相同屏幕位置的坐标值。CALayer类提供了一组简单的转换例程，可以用于此目的:
* convertPoint: fromLayer:
* convertPoint: toLayer:
* convertRect: fromLayer:
* convertRect: toLayer:

除了转换点和矩形值，你还可以使用convertTime:fromLayer:和convertTime:toLayer:方法在图层之间转换时间值。每个图层定义自己的本地时间空间，并使用该时间空间与系统的其余部分同步动画的开始和结束。默认情况下，这些时间空间是同步的;然而，如果你改变一组图层的动画速度，这些图层的时间空间也会相应改变。你可以使用时间转换方法来考虑任何此类因素，并确保两个图层的时间同步。
 
## 高级动画技巧
有许多方法可以配置基于属性的动画或关键帧动画来为你做更多的事情。需要一起或顺序执行多个动画的应用程序可以使用更高级的行为来同步这些动画的时间或将它们链接在一起。你还可以使用其他类型的动画对象来创建视觉过渡和其他有趣的动画效果。
 
### 过渡动画支持图层可见性的改变
顾名思义，过渡动画对象为图层创建动画视觉过渡。过渡对象最常见的用途是以协调的方式使一图层的出现和另一图层的消失产生动画效果。与基于属性的动画不同，在基于属性的动画中，动画会改变一个图层的一个属性，而过渡动画会操作一个图层的缓存图像来创建视觉效果，这很难或不可能通过单独改变属性来实现。标准类型的转场允许你执行显示、推动、移动或交叉渐变动画。

要执行转换动画，你需要创建一个转换对象，并将其添加到与转换相关的图层中。你可以使用转换对象来指定要执行的转换类型以及转换动画的开始和结束点。你也不需要使用整个过渡动画。转换对象允许你指定动画时要使用的开始和结束进度值。这些值让你可以在动画的中点开始或结束动画。

清单5-1显示了用于在两个视图之间创建动画推送转换的代码。在这个例子中，myView1和myView2都位于同一个父视图中的相同位置，但是目前只有myView1是可见的。push转换导致myView1向左滑动并逐渐消失，直到它被隐藏，而myView2从右侧滑动并变为可见。更新两个视图的hidden属性确保在动画结束时两个视图的可见性都是正确的。
![IMAGE](resources/018D0D55BBEE8680C9B382F2C2150B32.jpg =753x389)
当同一转换涉及两个层时，你可以对两者使用相同的转换对象。使用相同的转换对象也简化了必须编写的代码。但是，你可以使用不同的过渡对象，并且如果每个层的过渡参数不同，则肯定需要这样做。

清单5-2展示了如何在OS x上使用核心图像过滤器来实现过渡效果。在用你想要的参数配置过滤器之后，将其分配给过渡对象的filter属性。之后，应用动画的过程与应用其他类型的动画对象的过程相同。
![IMAGE](resources/36DD257B1D919277034E70108A7D88A1.jpg =885x455)

### 自定义动画的时间
计时是动画的重要组成部分，使用Core Animation，你可以通过CAMediaTiming协议的方法和属性为动画指定精确的计时信息。两个Core Animation类采用了这个协议。CAAnimation类采用它，这样你就可以在动画对象中指定计时信息。CALayer也采用它，以便你可以为隐式动画配置一些与时间相关的特性，尽管包装这些动画的隐式事务对象通常提供优先级的默认时间信息。

当考虑时间和动画时，理解图层对象如何随时间工作是很重要的。每个图层都有自己的本地时间，用来管理动画计时。通常，两个不同图层的本地时间非常接近，你可以为每个图层指定相同的时间值，而用户可能不会注意到任何东西。然而，一个图层的本地时间可以被它的父层或它自己的定时参数修改。例如，改变图层的速度属性会导致该图层(及其子图层)上的动画持续时间按比例改变。

为了帮助你确保时间值适合给定的层，CALayer类定义了convertTime:fromLayer:和convertTime:toLayer:方法。你可以使用这些方法将固定时间值转换为某一图层的本地时间，或者将时间值从一层转换为另一层。这些方法考虑到可能影响图层的本地时间的媒体计时属性，并返回一个可用于另一图层的值。清单5-3显示了一个示例，你应该经常使用它来获取图层的当前本地时间。CACurrentMediaTime函数是一个方便的函数，它返回计算机当前的时钟时间，该方法将其转换为图层的本地时间。
![IMAGE](resources/2FBC63824E167EB09CDEB25DBA1A269A.jpg =728x69)

一旦你在图层的本地时间中有了一个时间值，你就可以使用这个值来更新动画对象或图层的与时间相关的属性。有了这些计时属性，你可以实现一些有趣的动画行为，包括:

* 使用beginTime属性来设置动画的开始时间。通常，动画在下一个更新周期开始。你可以使用beginTime参数将动画开始时间延迟几秒钟。将两个动画链接在一起的方法是将一个动画的开始时间设置为与另一个动画的结束时间匹配。
如果你延迟动画的开始，你可能还想将fillMode属性设置为kCAFillModeBackwards。这种填充模式导致图层显示动画的开始值，即使图层树中的图层对象包含不同的值。如果没有这个填充模式，你会看到在动画开始执行之前跳转到最终值。其他填充模式也可用。

* autoreverses属性使动画在指定的持续时间内执行，然后返回到动画的起始值。你可以将此属性与repeatCount属性结合使用，以便在开始值和结束值之间来回显示动画。将自动反转动画的重复计数设置为整数(例如1.0)将导致动画在其起始值上停止。添加额外的半步(例如重复计数为1.5)会导致动画在其结束值上停止。

* 在组动画中使用timeOffset属性，可以在较晚的时间启动一些动画。

### 暂停和恢复动画
要暂停动画，你可以利用层采用CAMediaTiming协议的事实，并将层的动画速度设置为0.0。将速度设置为零将暂停动画，直到将该值更改回非零值。清单5-4显示了稍后如何暂停和恢复动画的简单示例。
![IMAGE](resources/6EC1B8CD166774FB0CFC18AA7F414133.jpg =818x382)
 
### 显式事务让你改变动画参数
对图层所做的每一次更改都必须是事务的一部分。CATransaction类管理动画的创建和分组，并在适当的时候执行。在大多数情况下，你不需要创建自己的事务。每当你向你的一个图层添加显式或隐式动画时，核心动画自动创建一个隐式事务。但是，你也可以创建显式事务来更精确地管理这些动画。

你可以使用CATransaction类的方法创建和管理事务。要启动(并隐式创建)一个新的事务，调用begin类方法;要结束该事务，请调用commit类方法。在这些调用之间是你希望成为事务一部分的更改。例如，要更改一个层的两个属性，可以使用清单5-5中的代码。
![IMAGE](resources/8386CD2788D818C3AD5CA4A836B8939C.jpg =500x139)

使用事务的一个主要原因是，在显式事务的范围内，你可以更改持续时间、计时功能和其他参数。你也可以为整个事务分配一个完成块，这样当一组动画完成时，你的应用就可以得到通知。更改动画参数需要使用setValue:forKey:方法在事务字典中修改适当的键。例如，要将默认持续时间更改为10秒，您可以更改kCATransactionAnimationDuration键，如清单5-6所示。
![IMAGE](resources/9B7F9A88D30F86C04015F4E77E99CF22.jpg =620x158)

你可以在希望为不同的动画集提供不同默认值的情况下嵌套事务。要将一个事务嵌套到另一个事务中，只需再次调用begin类方法。每个begin调用都必须匹配对应的commit方法调用。只有在提交最外层事务的更改之后，Core Animation才会开始相关的动画。
清单5-7显示了一个事务嵌套在另一个事务中的示例。在这个例子中，内部事务改变了与外部事务相同的动画参数，但使用了不同的值。
![IMAGE](resources/4DC3E247BD27ECE7A517BB58D6B1BDF4.jpg =529x528)

### 添加透视到你的动画
应用程序可以在三维空间中操作图层，但为了简单起见，Core Animation 使用平行投影来显示图层，这实际上是将场景扁平化为二维平面。这种默认行为导致具有不同zPosition值的相同大小的图层显示为相同大小，即使它们在z轴上相距很远。你通常在三维中观看这种场景的视角消失了。但是，你可以通过修改层的转换矩阵来包含透视图信息来改变这种行为。

当修改场景的透视图时，你需要修改包含被查看层的超层的sublayerTransform矩阵。通过对所有子层应用相同的透视图信息，修改超层简化了必须编写的代码。它还确保透视正确应用于在不同平面上相互重叠的兄弟子层。

清单5-8显示了为父层创建简单透视图转换的方法。在这种情况下，自定义eyePosition变量指定沿z轴查看图层的相对距离。通常，你为eyePosition指定一个正值，以保持图层以预期的方式定向。较大的值会导致更平坦的场景，而较小的值会导致图层之间更明显的视觉差异。
![IMAGE](resources/EF63041EAB5A756786BC2A86E4F5C9F2.jpg =559x157)
配置了父图层后，你可以更改任何子层的zPosition属性，并观察它们的大小如何根据它们与眼睛位置的相对距离而变化。
 
## 改变图层的默认行为
Core Animation使用action对象为图层实现其隐含的动画行为。操作对象是符合CAAction协议的对象，它定义了要在层上执行的一些相关行为。所有CAAnimation对象都实现了这个协议，当一个层的属性发生变化时，这些对象通常会被分配执行。

动画属性是一种类型的动作，但你可以用几乎任何你想要的行为来定义动作。要做到这一点，你必须定义你的动作对象，并将它们与你的应用程序的图层对象相关联。

### 自定义动作对象采用CAAction协议
要创建你自己的操作对象，请从你的一个类中采用CAAction协议并实现runActionForKey:object:arguments:方法。在这种方法中，使用可用信息来执行你想要在图层上执行的任何操作。你可以使用该方法将动画对象添加到图层中，或者使用它来执行其他任务。

在定义操作对象时，必须决定如何触发该操作。操作的触发器定义了稍后用于注册该操作的密钥。操作对象可以在以下任何情况下触发:

* 图层的一个属性值改变了。这可以是任何图层的属性，而不仅仅是动画属性。(你也可以将动作与添加到图层的自定义属性相关联。)标识此操作的键是属性的名称。
* 图层变得可见或被添加到一个图层层次中。标识此操作的键是kCAOnOrderIn。
* 该图层从图层层次结构中删除。标识此操作的键是kCAOnOrderOut。
* 这一层将涉及到一个过渡动画。标识此操作的键是kCATransition。

### 动作对象必须安装在图层上才能产生效果
在执行一个操作之前，该图层需要找到相应的要执行的操作对象。与图层相关的操作的键要么是被修改的属性的名称，要么是标识操作的特殊字符串。当一个适当的事件在图层上发生时，图层调用它的actionForKey:方法来搜索与该键关联的动作对象。你的应用程序可以在搜索过程中的几个点插入自己，并为那个键提供一个相关的操作对象。

Core Animation按照以下顺序查找动作对象:

1. 如果层有一个委托，并且该委托实现了actionForLayer:forKey:方法，图层调用该方法。委托必须执行以下操作之一:
* 返回给定键的操作对象。
* 如果不处理该操作，则返回nil，在这种情况下继续搜索。
* 返回NSNull对象，在这种情况下搜索立即结束。
2. 图层在图层的动作字典中查找给定的键。
3. 该层在样式字典中查找包含键的动作字典。(换句话说，样式字典包含一个动作键，它的值也是一个字典。图层在第二个字典中查找给定的键。)
4. 该图层调用它的defaultActionForKey:类方法。
5. 该图层执行由核心动画定义的隐式动作(如果有的话)。
 
如果在任何适当的搜索点提供操作对象，则该图层停止其搜索并执行返回的操作对象。当它找到一个动作对象时，该层调用该对象的runActionForKey:object:arguments:方法来执行动作。如果为给定键定义的动作已经是CAAnimation类的实例，则可以使用该方法的默认实现来执行动画。如果你正在定义符合CAAction协议的自定义对象，则必须使用该方法的对象实现来采取适当的操作。

在哪里安装动作对象取决于你打算如何修改层。

* 对于你可能只在特定情况下应用的操作，或者对于已经使用委托对象的层，提供一个委托并实现它的actionForLayer:forKey:方法。
* 对于通常不使用委托的图层对象，将动作添加到图层的动作字典中。
* 对于与你在图层对象上定义的自定义属性相关的操作，请将该操作包含在图层的样式字典中。
* 对于图层行为的基础操作，子类化图层并覆盖defaultActionForKey:方法。

清单6-1显示了用于提供操作对象的委托方法的实现。在这种情况下，委托查找对层的contents属性的更改，并使用过渡动画将新内容交换到适当的位置。
![IMAGE](resources/39164A10300AE9717D4BA497ADCE6BA6.jpg =884x379)

### 使用CATransaction类临时禁用操作
你可以使用CATransaction类暂时禁用图层动作。当你改变一个图层的属性时，Core Animation 通常会创建一个隐式的事务对象来动画化这个改变。如果你不想让更改变成动画，你可以通过创建显式事务并将其kCATransactionDisableActions属性设置为true来禁用隐式动画。
清单6-2显示了当从图层树中删除指定图层时禁用动画的代码片段。
![IMAGE](resources/321309CDEB38A01BD2BBC68BE58281B1.jpg =559x155)

## 提高动画性能
核心动画是提高基于应用的动画帧率的好方法，但它的使用并不能保证性能的提高。特别是在OS X 中，你仍然必须选择最有效的方式来使用核心动画行为。与所有与性能相关的问题一样，你应该使用工具来衡量和跟踪应用的性能，这样你就可以确保性能在不断提高，而不是倒退。
 
### 一般提示和技巧
有几种方法可以提高层实现的效率。但是，与任何此类优化一样，你应该在尝试优化之前始终测量代码的当前性能。这为你提供了一个基线，你可以使用它来确定优化是否有效。
 
#### 尽可能使用不透明图层
将图层的不透明属性设置为YES，让Core Animation 知道它不需要为图层维持alpha通道。没有alpha通道意味着合成器不需要将图层的内容与其背景内容混合，这节省了渲染时的时间。然而，这个属性主要与作为图层支持视图的一部分的图层或核心动画创建底层位图的情况相关。如果你将图像直接分配给图层的contents属性，则该图像的alpha通道将被保留，而不考虑opaque属性中的值。
 
#### 为CAShapeLayer对象使用更简单的路径
CAShapeLayer类通过在合成时将你提供的路径呈现为位图图像来创建其内容。这样做的好处是，图层总是以最好的分辨率绘制路径，但这种好处是以额外的渲染时间为代价的。如果你提供的路径很复杂，那么对该路径进行栅格化的成本可能会太高。如果图层的大小经常变化(因此必须频繁地重新绘制)，那么绘制所花费的时间就会累积起来，成为性能瓶颈。
减少形状图层绘制时间的一种方法是将复杂的形状分解成更简单的形状。在合成器中使用更简单的路径并将多个CAShapeLayer对象层叠在一起比绘制一个大的复杂路径要快得多。这是因为绘图操作发生在CPU上，而合成操作发生在GPU上。但是，对于这种性质的任何简化，潜在的性能增益取决于你的内容。因此，在优化之前测量代码的性能是特别重要的，这样你就有了一个用于比较的基准。
 
#### 明确设置相同图层的图层内容
如果你在多个图层对象中使用相同的图像，自己加载图像并将其直接分配给那些图层对象的contents属性。将图像分配给contents属性可防止图层为后备存储分配内存。相反，该图层使用你提供的图像作为其后备存储。当多个图层使用相同的图像时，这意味着所有这些层共享相同的内存，而不是为自己分配图像的副本。
 
#### 总是设置一个图层的大小为整数值
为了获得最佳效果，始终将图层对象的宽度和高度设置为整数值。虽然你使用浮点数指定图层边界的宽度和高度，但图层边界最终用于创建位图图像。指定宽度和高度的整数值简化了Core Animation在创建和管理后台存储和其他图层信息时必须做的工作。
 
#### 根据需要使用异步图层渲染
你在委托的drawLayer:inContext:方法或视图的drawRect:方法中所做的任何绘图通常都会同步发生在应用的主线程上。但是，在某些情况下，同步绘制内容可能不会提供最佳性能。如果你注意到你的动画没有很好地执行，你可以尝试在你的图层上启用drawsAsynchronously 异步属性，将这些操作移动到后台线程。如果这样做，请确保你的绘图代码是线程安全的。与往常一样，在将其放入产品代码之前，你应该始终测量异步绘图的性能。
 
#### 在给图层添加阴影时指定一个阴影路径
让核心动画来决定阴影的形状是很昂贵的，而且会影响应用的性能。不是让核心动画决定阴影的形状，而是使用CALayer的阴影路径属性显式指定阴影形状。当你为此属性指定路径对象时，Core Animation 将使用该形状来绘制和缓存阴影效果。对于形状从不改变或很少改变的图层，通过减少核心动画完成的渲染量，这大大提高了性能。

## 参考
1. https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514-CH1-SW1
2. https://juejin.cn/post/6844903839779274765
3. https://zsisme.gitbooks.io/ios-/content/chapter1/layers-and-trees.html