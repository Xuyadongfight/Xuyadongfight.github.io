### 1.扩展和分类(类别)的区别？
扩展在定义的形式上和类别的定义因为看起来仅仅是少了括号中的类别名称。所以扩展也被称为匿名分类(类别)。
但实际上扩展和分类的的差别很大。
1.扩展可以添加属性，成员变量，方法。而分类则只能给类添加方法，不能添加属性。通过runtime添加属性的方法本质上只是添加了一个不存贮在类结构中的可以存取的值。
2.扩展的属性和方法在编译时就成为了类结构的一部分。而分类的方法则是在运行时才添加到类结构中。

#### 具体分类的添加过程是什么样的?
1.分类实际上会生成`category_t`类型的结构体
![IMAGE](resources/19526290CE51F2D9A3241ED8F28AC453.jpg =771x299)
2.在runtime的过程中会通过`attachCategories`方法将分类添加到类结构中。
![iShot_2023-03-10_16.35.04.png](resources/33EF6228F6B10DF99F6B6AE24379DAD2.png =834x1078)
`category_list`其实就是稍微包装了一下的`category_t`。
而在添加分类的过程中会将分类的方法添加到类本身的方法之前。这也是为什么存在同名的方法的时候，会调用分类的方法。当多个分类存在同名的方法时，根据分类的加载顺序，实际调用的方法是后加载的分类中的方法。

### 2.分类能添加属性吗？为什么？
如果属性仅仅只是表示set,get方法。那么分类可以使用runtime添加属性。但是可以肯定的是分类不能添加成员变量。因为成员变量是在编译时就确定的存储在`class_ro_t`这个只读的结构中。使用runtime的`objc_setAssociatedObject`和`objc_getAssociatedObject`能够实现set和get方法。并且这个关联的值是存储在全局的一个`AssociationsHashMap`类型的哈希表中。
![IMAGE](resources/A02492517CB74592930602EFF9D6FE2B.jpg =784x794)
这个表大概是以需要关联对象地址作为key设置一个`ObjectAssociationMap`的哈希表。其中又已你传入的key作为哈希表的键，以被关联的对象作为值。

### 3.多个分类定义同名的方法，调用顺序是什么样的？覆盖了类本身定义的方法又是什么样的?
多个分类定义的同名方法根据分类的加载顺序。最后调用的方法是后加载的分类文件中的方法。对与和类本身定义的方法相同的。也是根据加载分类文件的顺序。实际最后调用的方法是最后加载的那个分类中定义的方法。虽然看起来是覆盖了类本身定义的方法。但实际上并不是覆盖。分类的方法和类本身的方法都在类结构中。只不过是因为后加载的分类的方法在类结构中的方法列表前面。使得方法查找的时候被先找到调用。

### 4.load和initialize的区别?
load类方法是当类被动态加载或者静态链接的时候调用。前提是在类或者分类中实现了load方法。
初始化顺序是
1.链接到任何框架中的所有类的初始化
2.内存镜像中的所有的load方法
3.内存镜像中的所有c++静态初始化器和c/c++中的__attribute__(constructor)函数
4.框架中链接到你的所有初始化
此外:
* 类的load方法是在它所有超类的load方法之后调用的
* 分类的load方法是在类自身的load方法之后调用的
因此在load的自定义实现中，可以安全的从同一个镜像向其它不相关的类发送消息。但是这些类实现的任何load方法可能还没有运行。
initialize方法是在类收到第一条消息的时候调用的
运行时将initialize发送给程序中的每个类。在该类或者从该类继承的任何子类发送第一条消息之前。父类在子类之前收到此消息。运行时以线程安全的方式将initialize消息发送给类。也就是说initialize由第一个线程运行，用于向类发送消息，而任何其它试图向该类发送消息的线程将阻塞，直到initialize完成。如果子类没有实现initialize。运行时将调用继承的实现。如果子类显式调用`[super initialize]`，则父类实现可能会被调用多次。如果想要保护自己不被多次调用。可以使用以下方式处理:
```
+ (void)initialize {
  if (self == [ClassName self]) {
    // ... do the initialization ...
  }
}
```
因为initialize是以阻塞的方式调用，所以将方法实现限制为尽可能少的工作是很重要的。具体点就是任何接收initialize方法中其它类可能需要锁的代码都可能导致死锁。因此，不应该依赖initialize进行复杂的初始化，而应该将其限制为简单的类本地初始化。
另外要注意的是，initialize每个类只会调用一次。如果你想对类和这个类的分类使用独立的初始化，应该使用load方法。

### 5.对一个类添加多个分类的load方法是什么情况?为什么和普通的方法表现不一样?
一个类添加多个分类的load方法。每个load方法都会调用。
因为load方法并不是通过普通的消息发送进行调用的。而是在动态链接器中使用方法地址调用的。所以不会存在普通方法调用中多个同名方法，只会调用最后加载的那个方法。