## 并发性和应用程序设计
在计算的早期，计算机在单位时间内所能执行的最大工作量是由CPU的时钟速度决定的。但随着技术的进步和处理器设计变得更加紧凑，热量和其他物理限制开始限制处理器的最大时钟速度。因此，芯片制造商寻找其他方法来提高芯片的总体性能。他们确定的解决方案是增加每个芯片上的处理器核心数量。通过增加核数，单个芯片可以在不增加CPU速度或改变芯片大小或热特性的情况下每秒执行更多指令。唯一的问题是如何利用额外的核心。

为了利用多核的优势，计算机需要能同时做多件事的软件。对于像OSX或iOS这样的现代多任务操作系统，在任何给定的时间都可能有100个或更多的程序在运行，因此将每个程序安排在不同的核心上应该是可能的。然而，这些程序中的大多数要么是系统守护进程，要么是后台应用程序，实际处理时间很少。相反，真正需要的是让单个应用程序更有效地利用额外内核的方法。

应用程序使用多核的传统方法是创建多个线程。然而，随着内核数量的增加，线程解决方案也会出现问题。最大的问题是线程代码不能很好地扩展到任意数量的内核。您不能创建与内核数量一样多的线程，并期望程序运行良好。您需要知道的是可以有效使用的内核数量，这对于应用程序本身来说是一个具有挑战性的事情。即使您设法得到正确的数字，仍然存在为这么多线程编程、使它们高效运行以及防止它们相互干扰的挑战。

因此，总结这个问题，需要有一种方法让应用程序利用可变数量的计算机核心。单个应用程序执行的工作量还需要能够动态扩展，以适应不断变化的系统条件。解决方案必须足够简单，以免增加利用这些核心所需的工作量。好消息是，苹果的操作系统为所有这些问题提供了解决方案，本章将介绍组成这个解决方案的技术，以及你可以对代码进行的设计调整，以利用它们。
 
## 远离线程
尽管线程已经存在了许多年，并且仍在继续使用，但它们并不能解决以可伸缩的方式执行多个任务的一般问题。使用线程，创建可伸缩解决方案的重担完全落在开发人员的肩上。您必须决定要创建多少个线程，并随着系统条件的变化动态地调整这个数字。另一个问题是，您的应用程序承担了与创建和维护它所使用的任何线程相关的大部分成本。

OSX和iOS不依赖线程，而是采用异步设计方法来解决并发问题。异步函数已经出现在操作系统中很多年了，通常用于启动可能需要很长时间的任务，比如从磁盘读取数据。当调用异步函数时，它在幕后执行一些工作以启动任务运行，但在该任务可能实际完成之前返回。通常，这项工作包括获取一个后台线程，在该线程上启动所需的任务，然后在任务完成时向调用者发送通知(通常通过回调函数)。在过去，如果您想要做的事情没有异步函数，那么您必须编写自己的异步函数并创建自己的线程。但是现在，OSX和iOS提供了允许你异步执行任何任务的技术，而不必自己管理线程。

异步启动任务的技术之一是大中央调度(GCD)。这项技术将您通常在自己的应用程序中编写的线程管理代码移到系统级。您所要做的就是定义要执行的任务，并将它们添加到适当的调度队列中。GCD负责创建所需的线程，并安排在这些线程上运行的任务。因为线程管理现在是系统的一部分，所以GCD提供了一种整体的任务管理和执行方法，提供了比传统线程更好的效率。

操作队列是Objective-C对象，它的作用非常类似于调度队列。定义要执行的任务，然后将它们添加到操作队列，该操作队列处理这些任务的调度和执行。与GCD类似，操作队列为您处理所有线程管理，确保任务在系统上尽可能快速高效地执行。

## 调度队列（GCD）
调度队列是一种基于c语言的机制，用于执行自定义任务。调度队列可以串行地或并发地执行任务，但总是按照先进先出的顺序执行。(换句话说，调度队列总是按照将任务添加到队列中的相同顺序出队列并启动任务。)串行调度队列一次只运行一个任务，在退出队列并开始一个新任务之前等待该任务完成。相比之下，并发调度队列启动尽可能多的任务，而无需等待已经启动的任务完成。
调度队列还有其他好处:
* 它们提供了直接而简单的编程接口。
* 它们提供自动和整体的线程池管理。
* 它们提供了调优组装的速度。
* 它们的内存效率要高得多(因为线程堆栈不会在应用程序内存中逗留)。
* 它们不会在负载下捕获到内核。
* 将任务异步分派到调度队列不会导致队列死锁。
* 它们在竞争中优雅地扩展。
* 串行调度队列为锁和其他同步原语提供了更有效的替代方案。

提交给调度队列的任务必须封装在函数或块对象中。块对象是在OSXv10.6和iOS4.0中引入的C语言特性，在概念上类似于函数指针，但有一些额外的好处。您通常在另一个函数或方法中定义块，而不是在它们自己的词法作用域中定义块，以便它们可以从该函数或方法访问其他变量。块也可以移出其原始作用域并复制到堆上，这是将它们提交给调度队列时所发生的情况。所有这些语义使得用相对较少的代码实现非常动态的任务成为可能。
调度队列是GCD的一部分，也是C运行时的一部分。有关在应用程序中使用分派队列的详细信息，请参见调度队列。有关块及其优点的更多信息，请参见块编程主题。
 
## 调度源
调度源是一种基于c语言的机制，用于异步处理特定类型的系统事件。调度源封装关于特定类型的系统事件的信息，并在该事件发生时向调度队列提交特定的块对象或函数。您可以使用调度源监视以下类型的系统事件:
* 计时器
* 信号处理程序
* Descriptor-related事件
* 进程相关的事件
* Mach端口事件
* 你触发的自定义事件

调度源是GCD术的一部分。有关在应用程序中使用分派源接收事件的信息，请参见调度源。
 
## 操作队列
操作队列相当于Cocoa中的并发调度队列，由NSOperationQueue类实现。调度队列总是按照先进先出的顺序执行任务，而操作队列在确定任务的执行顺序时要考虑其他因素。这些因素中最主要的是给定的任务是否依赖于其他任务的完成。在定义任务时配置依赖项，并可以使用它们为任务创建复杂的执行顺序图。

你提交给操作队列的任务必须是NSOperation类的实例。操作对象是一个Objective-C对象，它封装了您想要执行的工作以及执行该工作所需的任何数据。因为NSOperation类本质上是一个抽象基类，你通常定义自定义子类来执行你的任务。但是，Foundation框架确实包含一些具体的子类，您可以按原样创建和使用它们来执行任务。

操作对象生成键值观察(KVO)通知，这是监视任务进度的有用方法。尽管操作队列总是并发地执行操作，但您可以使用依赖项来确保在需要时串行地执行它们。

有关如何使用操作队列以及如何定义自定义操作对象的详细信息，请参见操作队列。
 
## 异步设计技术
在考虑重新设计代码以支持并发性之前，您应该问问自己这样做是否有必要。并发性可以通过确保主线程可以自由地响应用户事件来提高代码的响应能力。它甚至可以通过利用更多的核心在相同的时间内完成更多的工作来提高代码的效率。然而，这也增加了开销，增加了代码的整体复杂性，使得编写和调试代码更加困难。

由于并发性增加了复杂性，所以不能在产品周期结束时将其移植到应用程序中。正确地执行它需要仔细考虑应用程序执行的任务以及用于执行这些任务的数据结构。如果操作不当，您可能会发现代码运行速度比以前慢，对用户的响应也更慢。因此，在设计周期开始时花点时间设定一些目标并考虑需要采取的方法是值得的。

每个应用程序都有不同的需求和执行的不同任务集。文档不可能确切地告诉您如何设计应用程序及其相关任务。但是，下面的部分试图提供一些指导，以帮助您在设计过程中做出正确的选择。
 
### 定义应用程序的预期行为
在考虑向应用程序添加并发性之前，应该首先定义应用程序的正确行为。理解应用程序的预期行为为以后验证设计提供了一种方法。它还可以让您了解引入并发可能带来的预期性能好处。

您应该做的第一件事是枚举应用程序执行的任务以及与每个任务关联的对象或数据结构。最初，您可能希望从用户选择菜单项或单击按钮时执行的任务开始。这些任务提供离散的行为，并有明确定义的起点和终点。您还应该列举应用程序可能在没有用户交互的情况下执行的其他类型的任务，例如基于计时器的任务。

有了高级任务列表之后，开始将每个任务进一步分解为成功完成任务必须采取的一组步骤。在这个级别上，您应该主要关注需要对任何数据结构和对象进行的修改，以及这些修改如何影响应用程序的整体状态。您还应该注意对象和数据结构之间的依赖关系。例如，如果一项任务涉及对对象数组进行相同的更改，那么值得注意对一个对象的更改是否会影响其他对象。如果对象可以彼此独立地修改，那么就可以在那里同时进行这些修改。
 
### 分解出可执行的工作单元
通过对应用程序任务的理解，您应该已经能够确定代码可能从并发性中受益的地方。如果更改任务中一个或多个步骤的顺序会改变结果，则可能需要继续连续执行这些步骤。但是，如果更改顺序对输出没有影响，则应该考虑同时执行这些步骤。在这两种情况下，您都定义了表示要执行的步骤的可执行工作单元。然后，这个工作单元就变成了使用块或操作对象封装并分派到适当队列的内容。

对于您确定的每个可执行工作单元，不要过于担心正在执行的工作量，至少在最初是这样。尽管旋转线程总是有成本，但调度队列和操作队列的优点之一是，在许多情况下，这些成本比传统线程要小得多。因此，您可以使用队列比使用线程更有效地执行较小的工作单元。当然，您应该始终衡量您的实际性能，并根据需要调整任务的大小，但最初，不应该认为任务太小。
 
### 确定您需要的队列
现在，您的任务被分解为不同的工作单元，并使用块对象或操作对象进行封装，您需要定义用于执行该代码的队列。对于给定的任务，检查您创建的块或操作对象，以及正确执行任务时必须执行它们的顺序。

如果使用块实现任务，则可以将块添加到串行或并发调度队列中。如果需要特定的顺序，则始终将块添加到串行调度队列中。如果不需要特定的顺序，您可以将这些块添加到并发调度队列中，或者根据需要将它们添加到几个不同的调度队列中。

如果使用操作对象实现任务，那么队列的选择通常没有对象的配置有趣。若要连续执行操作对象，必须配置相关对象之间的依赖关系。依赖关系阻止一个操作在它所依赖的对象完成它们的工作之前执行。
 
### 提高效率的技巧
除了简单地将代码分解成更小的任务并将它们添加到队列中之外，还有其他方法可以使用队列提高代码的整体效率:

如果内存使用是一个因素，请考虑直接在任务中计算值。如果应用程序已经受到内存限制，那么现在直接计算值可能比从主存加载缓存值更快。计算值直接使用给定处理器核心的寄存器和缓存，这比主存快得多。当然，只有在测试表明这样做对性能有利时才应该这样做。
尽早识别串行任务，并尽你所能使它们更加并发。如果一个任务必须串行执行，因为它依赖于一些共享资源，请考虑更改您的体系结构以删除该共享资源。您可以考虑为每个需要资源的客户端复制资源，或者完全删除资源。
避免使用锁。调度队列和操作队列提供的支持使得锁在大多数情况下都不需要。与其使用锁来保护一些共享资源，不如指定一个串行队列(或使用操作对象依赖关系)以正确的顺序执行任务。
尽可能依赖于系统框架。实现并发性的最佳方法是利用系统框架提供的内置并发性。许多框架在内部使用线程和其他技术来实现并发行为。在定义任务时，查看现有框架是否定义了一个函数或方法，该函数或方法可以同时执行您想要的操作。使用该API可以节省您的工作量，并且更有可能为您提供最大的并发性。
 
### 性能影响
提供了操作队列、分派队列和分派源，使您更容易同时执行更多代码。但是，这些技术并不能保证提高应用程序的效率或响应能力。您仍然有责任以一种既能有效满足您的需求，又不会对应用程序的其他资源造成不必要负担的方式使用队列。例如，尽管您可以创建10,000个操作对象并将它们提交给操作队列，但这样做将导致应用程序分配大量内存，这可能导致分页和性能下降。

在向代码引入任何数量的并发性之前(无论是使用队列还是线程)，您应该始终收集一组反映应用程序当前性能的基准指标。在引入更改之后，您应该收集额外的度量标准，并将它们与基线进行比较，以查看应用程序的整体效率是否有所提高。如果引入并发使应用程序的效率或响应更低，则应该使用可用的性能工具来检查潜在的原因。

有关性能和可用性能工具的介绍，以及到更高级性能相关主题的链接，请参见性能概述。
 
## 并发性和其他技术
将代码分解为模块化任务是尝试和提高应用程序并发性的最佳方法。然而，这种设计方法可能不能满足每种情况下每种应用程序的需求。根据您的任务，可能有其他选项可以在应用程序的整体并发性方面提供额外的改进。本节概述了在设计中可以考虑使用的其他一些技术。
 
### OpenCL和并发
在OS X中，开放计算语言(OpenCL)是一种基于标准的技术，用于在计算机图形处理器上执行通用计算。如果您有一个定义良好的计算集，并希望将其应用于大型数据集，那么OpenCL是一种很好的技术。例如，您可以使用OpenCL对图像的像素执行筛选计算，或者使用它一次对多个值执行复杂的数学计算。换句话说，OpenCL更倾向于那些数据可以并行运算的问题集。

尽管OpenCL很适合执行大规模数据并行操作，但它不适用于更通用的计算。准备数据和所需的工作内核并将其传输到图形卡，以便GPU可以对其进行操作，这需要大量的工作。类似地，检索OpenCL生成的任何结果都需要大量的工作。因此，任何与系统交互的任务通常都不推荐与OpenCL一起使用。例如，您不会使用OpenCL来处理来自文件或网络流的数据。相反，使用OpenCL执行的工作必须更加自包含，以便它可以传输到图形处理器并独立计算。

有关OpenCL以及如何使用它的更多信息，请参阅Mac版OpenCL编程指南。
 
### 何时使用线程
尽管操作队列和分派队列是并发执行任务的首选方式，但它们并不是万能的。根据应用程序的不同，有时可能仍然需要创建自定义线程。如果您确实创建了自定义线程，您应该努力自己创建尽可能少的线程，并且应该仅将这些线程用于无法通过其他方式实现的特定任务。

线程仍然是实现必须实时运行的代码的好方法。分派队列会尽可能快地运行它们的任务，但它们没有解决实时限制。如果需要从后台运行的代码中获得更多可预测的行为，线程可能仍然是一个更好的选择。

与任何线程编程一样，您应该始终明智地使用线程，并且只在绝对必要时使用。有关线程包以及如何使用它们的更多信息，请参阅线程编程指南。
 