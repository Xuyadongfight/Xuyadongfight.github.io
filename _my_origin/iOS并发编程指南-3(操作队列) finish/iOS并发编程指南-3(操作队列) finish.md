## Operation Queues
Cocoa operations 是一种面向对象的方法，用于封装希望异步执行的工作。Operations被设计成可以与operation queue一起使用，也可以单独使用。因为它们是基于Objective-C的，所以Operations最常用于OS X和iOS中基于cocoa的应用程序。

### 关于Operation对象
操作对象是NSOperation类的一个实例(在Foundation框架中)，你用它来封装你想要应用程序执行的工作。NSOperation类本身是一个抽象基类，为了做任何有用的工作，它必须被子类化。尽管这个类是抽象的，但它确实提供了大量的基础结构，以最大限度地减少在自己的子类中必须做的工作量。此外，Foundation框架提供了两个具体的子类，您可以在现有代码中原样使用它们。表2-1列出了这些类，以及如何使用它们的摘要。
![IMAGE](resources/1E16D17CD2144EE36F7CFBB74656D3D1.jpg =1180x317)

所有的操作对象都支持一下关键特性:
* 支持在操作对象之间建立基于图的依赖关系。这些依赖关系阻止给定操作运行，直到它所依赖的所有操作都运行完毕。有关如何配置依赖项的信息，请参见配置互操作依赖项。
* 支持可选的完成块，它在操作的主任务完成后执行。(仅限OS X v10.6及更高版本)有关如何设置完成块的信息，请参见设置完成块。
* 支持使用KVO通知监视操作执行状态的更改。有关如何观察KVO通知的信息，请参见键值观察编程指南。
* 支持确定操作的优先级，从而影响它们的相对执行顺序。有关详细信息，请参见更改操作的执行优先级。
* 支持取消语义，允许您在操作执行时暂停操作。有关如何取消操作的信息，请参见取消操作。有关如何在您自己的操作中支持取消的信息，请参见响应取消事件。

操作旨在帮助您提高应用程序中的并发级别。操作也是将应用程序的行为组织和封装成简单的离散块的好方法。您可以向队列提交一个或多个操作对象，而不是在应用程序的主线程上运行一些代码，并让相应的工作在一个或多个单独的线程上异步执行。

### 并发与非并发操作
虽然通常通过将操作添加到操作队列来执行操作，但并不需要这样做。也可以通过调用操作对象的start方法手动执行该操作对象，但这样做并不能保证该操作与其余代码同时运行。NSOperation类的isConcurrent方法告诉你一个操作对于调用它的start方法的线程是同步运行还是异步运行。默认情况下，此方法返回NO，这意味着操作在调用线程中同步运行。

如果希望实现并发操作(即相对于调用线程异步运行的操作)，则必须编写额外的代码以异步启动操作。例如，您可以生成一个单独的线程，调用异步系统函数，或执行其他任何操作，以确保start方法启动任务并立即返回，并且很可能在任务完成之前返回。

大多数开发人员不应该需要实现并发操作对象。如果总是将操作添加到操作队列中，则不需要实现并发操作。当您向操作队列提交非并发操作时，该队列本身将创建一个线程来运行您的操作。因此，将非并发操作添加到操作队列中仍然会导致操作对象代码的异步执行。只有在需要异步执行操作而不将其添加到操作队列的情况下，才需要定义并发操作。

有关如何创建并发操作的信息，请参见配置并发执行操作和NSOperation类参考。

### 创建NSInvocationOperation对象
NSInvocationOperation类是NSOperation的一个具体子类，当它运行时，调用你在指定对象上指定的选择器。使用这个类可以避免为应用程序中的每个任务定义大量的自定义操作对象;特别是如果您正在修改现有的应用程序，并且已经拥有执行必要任务所需的对象和方法。当您想要调用的方法可以根据环境而改变时，也可以使用它。例如，您可以使用调用操作来执行基于用户输入动态选择的选择器。

创建调用操作的过程非常简单。创建并初始化类的新实例，将需要执行的对象和选择器传递给初始化方法。
 ```
 @implementation MyCustomClass
- (NSOperation*)taskWithData:(id)data {
    NSInvocationOperation* theOp = [[NSInvocationOperation alloc] initWithTarget:self
                    selector:@selector(myTaskMethod:) object:data];
 
   return theOp;
}
 
// This is the method that does the actual work of the task.
- (void)myTaskMethod:(id)data {
    // Perform the task.
}
@end

 ```
 
### 创建NSBlockOperation对象
NSBlockOperation类是NSOperation的一个具体子类，它作为一个或多个块对象的包装器。该类为已经使用操作队列且不想同时创建分派队列的应用程序提供了面向对象的包装器。您还可以使用块操作来利用操作依赖项、KVO通知和分派队列可能无法提供的其他特性。

创建块操作时，通常在初始化时至少添加一个块;以后可以根据需要添加更多的块。当需要执行NSBlockOperation对象时，该对象将其所有的块提交给默认优先级的并发调度队列。然后，该对象等待所有块执行完毕。当最后一个块完成执行时，操作对象将自己标记为已完成。因此，您可以使用块操作来跟踪一组正在执行的块，就像使用线程连接来合并多个线程的结果一样。不同之处在于，由于块操作本身运行在单独的线程上，应用程序的其他线程可以在等待块操作完成的同时继续工作。

```
NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{
      NSLog(@"Beginning operation.\n");
      // Do some work.
   }];
``` 
创建块操作对象后，您可以使用addExecutionBlock:方法向其添加更多的块。如果需要连续执行块，则必须将它们直接提交到所需的调度队列。

### 定义一个自定义操作对象
如果块操作和调用操作对象不能完全满足应用程序的需要，你可以直接子类化NSOperation并添加任何你需要的行为。NSOperation类为所有操作对象提供了一个通用的子类化点。该类还提供了大量的基础设施来处理依赖项和KVO通知所需的大部分工作。但是，有时仍然需要补充现有的基础结构，以确保操作正确运行。需要做的额外工作量取决于实现的是非并发操作还是并发操作。

定义非并发操作比定义并发操作简单得多。对于非并发操作，你所要做的就是执行你的主要任务并适当地响应取消事件;现有的类基础结构为您完成所有其他工作。对于并发操作，必须用自定义代码替换一些现有的基础结构。下面几节将向您展示如何实现这两种类型的对象。

每个操作对象至少需要实现以下方法:
* 自定义初始化方法
* main

使用自定义初始化方法来将操作对象置于已知状态。使用main方法来执行任务。当然也可以实现额外的方法。比如:
* 计划从主方法的实现中调用的自定义方法
* 用于设置数据值和访问操作结果的访问器方法
* NSCoding协议的方法，以运行对操作对象进行存档和解档

```
@interface MyNonConcurrentOperation : NSOperation
@property id (strong) myData;
-(id)initWithData:(id)data;
@end
 
@implementation MyNonConcurrentOperation
- (id)initWithData:(id)data {
   if (self = [super init])
      myData = data;
   return self;
}
 
-(void)main {
   @try {
      // Do some work on myData and report the results.
   }
   @catch(...) {
      // Do not rethrow exceptions.
   }
}
@end
```

### 响应取消事件
在操作开始执行后，它将继续执行其任务，直到完成或直到您的代码显式地取消该操作。取消可以在任何时候发生，甚至在操作开始执行之前。尽管NSOperation类为客户端提供了一种取消操作的方法，但识别取消事件是必要的。如果一项操作被完全终止，可能就没有办法收回已分配的资源。因此，期望操作对象检查取消事件，并在它们发生在操作中间时优雅地退出。

要在操作对象中支持取消，你所要做的就是从你的自定义代码中定期调用对象的isCancelled方法，如果它返回YES，就立即返回。支持取消是非常重要的，无论你的操作持续时间长短，无论你是直接子类化NSOperation还是使用它的一个具体子类。isCancelled方法本身是非常轻量级的，可以频繁调用，而不会对性能造成重大影响。在设计你的操作对象时，你应该考虑在代码中的以下位置调用isCancelled方法:
* 在你开始任何实际工作之前
* 在循环的每次迭代中至少一次，如果每次迭代相对较长，则更频繁
* 在代码中任何相对容易中止操作的地方

```
- (void)main {
   @try {
      BOOL isDone = NO;
 
      while (![self isCancelled] && !isDone) {
          // Do some work and set isDone to YES when finished
      }
   }
   @catch(...) {
      // Do not rethrow exceptions.
   }
}
```
尽管上面的示例不包含清理代码，但你自己的代码应该确保释放自定义代码分配的任何资源。

### 配置并发执行操作
操作对象默认以同步方式执行——也就是说，它们在调用其start方法的线程中执行任务。由于操作队列为非并发操作提供了线程，因此大多数操作仍然异步运行。但是，如果您计划手动执行操作，并且仍然希望它们异步运行，则必须采取适当的操作来确保它们能够异步运行。为此，您可以将操作对象定义为并发操作。需要重写的几个方法。
![IMAGE](resources/514C22D01BA7808D80D5DD1FF34C5C88.jpg =1177x321)
 
### 定义一个并发操作MyOperation
下面显示了MyOperation类的接口和部分实现。MyOperation类的isConcurrent、isexecution和isFinished方法的实现相对简单。isConcurrent方法应该简单地返回YES，以表明这是一个并发操作。isexecution和isFinished方法只是返回存储在类本身实例变量中的值。
```
@interface MyOperation : NSOperation {
    BOOL        executing;
    BOOL        finished;
}
- (void)completeOperation;
@end
 
@implementation MyOperation
- (id)init {
    self = [super init];
    if (self) {
        executing = NO;
        finished = NO;
    }
    return self;
}
 
- (BOOL)isConcurrent {
    return YES;
}
 
- (BOOL)isExecuting {
    return executing;
}
 
- (BOOL)isFinished {
    return finished;
}
@end
```

接下来显示了MyOperation的启动方法。此方法的实现非常简单，以便演示您绝对必须执行的任务。在这种情况下，该方法只是启动一个新线程，并配置它来调用main方法。该方法还更新执行成员变量，并为isexecution键路径生成KVO通知，以反映该值的更改。工作完成后，该方法返回，让新分离的线程执行实际任务。
```
- (void)start {
   // Always check for cancellation before launching the task.
   if ([self isCancelled])
   {
      // Must move the operation to the finished state if it is canceled.
      [self willChangeValueForKey:@"isFinished"];
      finished = YES;
      [self didChangeValueForKey:@"isFinished"];
      return;
   }
 
   // If the operation is not canceled, begin executing the task.
   [self willChangeValueForKey:@"isExecuting"];
   [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];
   executing = YES;
   [self didChangeValueForKey:@"isExecuting"];
}
```

接下来显示了MyOperation类的其余实现。如上面所示，main方法是新线程的入口点。它执行与操作对象相关的工作，并在该工作最终完成时调用自定义completeOperation方法。然后，completeOperation方法为isexecution和isFinished键路径生成所需的KVO通知，以反映操作状态的变化。
```
- (void)main {
   @try {
 
       // Do the main work of the operation here.
 
       [self completeOperation];
   }
   @catch(...) {
      // Do not rethrow exceptions.
   }
}
 
- (void)completeOperation {
    [self willChangeValueForKey:@"isFinished"];
    [self willChangeValueForKey:@"isExecuting"];
 
    executing = NO;
    finished = YES;
 
    [self didChangeValueForKey:@"isExecuting"];
    [self didChangeValueForKey:@"isFinished"];
}
```
即使一个操作对象被取消，你也应随时通知KVO观察员你的操作对象现在已完成。当一个操作对象依赖于其他操作对象的完成时，它监视这些对象的isFinished键路径。只有当所有对象都报告它们已经完成时，依赖的操作才会发出信号表明它已经准备好运行了。因此，无法生成完成通知会阻止应用程序中其他操作的执行。

#### 维持KVO的规定
NSOperation类是键值观察(KVO)兼容的，适用于以下键路径:
* isCancelled
* isConcurrent
* isExecuting
* isFinished
* isReady
* dependencies
* queuePriority
* completionBlock

如果你重写了start方法或者对NSOperation对象做了任何重要的自定义而不是重写main，你必须确保你的自定义对象对这些关键路径保持KVO兼容。在重写start方法时，最应该关注的关键路径是isexecution和isFinished。这些是最常受到重新实现该方法影响的关键路径。

如果您希望实现对其他操作对象之外的依赖项的支持，您还可以覆盖isReady方法并强制它返回NO，直到您的自定义依赖项得到满足。(如果你实现了自定义依赖，如果你仍然支持NSOperation类提供的默认依赖管理系统，请确保从你的isReady方法调用super。)当操作对象的就绪状态发生变化时，为isReady键路径生成KVO通知，以报告这些变化。除非重写addDependency:或removeDependency:方法，否则不需要担心为依赖项关键路径生成KVO通知。

虽然你可以为NSOperation的其他关键路径生成KVO通知，但你不太可能需要这样做。如果需要取消某个操作，只需调用现有的cancel方法即可。类似地，您几乎不需要修改操作对象中的队列优先级信息。最后，除非您的操作能够动态地更改其并发状态，否则您不需要为isConcurrent键路径提供KVO通知。

### 定制操作对象的执行行为
操作对象的配置发生在创建它们之后，但在将它们添加到队列之前。本节中描述的配置类型可以应用于所有操作对象，无论您是自己继承了NSOperation的子类还是使用了现有的子类。
 
#### 配置互操作依赖项
依赖关系是一种序列化不同操作对象执行的方法。依赖于其他操作的操作只有在其所依赖的所有操作完成执行后才能开始执行。因此，您可以使用依赖关系在两个操作对象之间创建简单的一对一依赖关系，或者构建复杂的对象依赖关系图。

要在两个操作对象之间建立依赖关系，可以使用NSOperation的addDependency:方法。此方法创建了从当前操作对象到作为参数指定的目标操作的单向依赖关系。这种依赖关系意味着当前对象在目标对象完成执行之前不能开始执行。依赖关系也不局限于同一队列中的操作。操作对象管理它们自己的依赖关系，因此在操作之间创建依赖关系并将它们全部添加到不同的队列中是完全可以接受的。但是，有一件事是不能接受的，那就是在操作之间创建循环依赖关系。这样做是一个程序员错误，将阻止受影响的操作永远运行。

当操作的所有依赖项本身都完成执行时，操作对象通常就可以执行了。(如果您自定义了isReady方法的行为，则操作的就绪性由您设置的标准决定。)如果操作对象在队列中，队列可以在任何时候开始执行该操作。如果您计划手动执行该操作，则由您来调用该操作的start方法。

**重要提示:**在运行操作或将操作添加到操作队列之前，应该始终配置依赖项。之后添加的依赖关系可能不会阻止给定操作对象的运行。

依赖关系依赖于每个操作对象在对象状态改变时发送适当的KVO通知。如果自定义操作对象的行为，则可能需要从自定义代码生成适当的KVO通知，以避免引起依赖关系问题。

#### 修改操作的执行优先级
对于添加到队列中的操作，执行顺序首先由排队操作的就绪程度确定，然后由它们的相对优先级确定。准备就绪由操作对其他操作的依赖决定，但优先级是操作对象本身的属性。默认情况下，所有新的操作对象都有一个“正常”优先级，但是你可以根据需要通过调用对象的setQueuePriority:方法来增加或减少优先级。

优先级级别仅应用于同一操作队列中的操作。如果您的应用程序有多个操作队列，每个操作队列将独立于任何其他队列对自己的操作进行优先级排序。因此，低优先级操作仍然有可能在不同队列中的高优先级操作之前执行。

优先级级别不能代替依赖关系。优先级决定了操作队列只开始执行那些当前准备好的操作的顺序。例如，如果队列中同时包含高优先级和低优先级操作，并且两个操作都已就绪，则队列首先执行高优先级操作。但是，如果高优先级操作还没有准备好，而低优先级操作准备好了，队列就会先执行低优先级操作。如果您希望在另一个操作完成之前阻止一个操作开始，则必须使用依赖项(如配置互操作依赖项中所述)。
 
#### 改变底层线程优先级
在OS X v10.6及更高版本中，可以配置操作的底层线程的执行优先级。系统中的线程策略本身由内核管理，但通常高优先级线程比低优先级线程有更多的运行机会。在操作对象中，将线程优先级指定为范围为0.0到1.0的浮点值，其中0.0是最低优先级，1.0是最高优先级。如果没有指定显式的线程优先级，则该操作以默认的线程优先级0.5运行。

要设置一个操作的线程优先级，在将其添加到队列(或手动执行)之前，必须调用操作对象的setThreadPriority:方法。当需要执行操作时，默认的start方法使用您指定的值来修改当前线程的优先级。这个新的优先级仅在操作的主方法期间有效。所有其他代码(包括操作的完成块)都以默认的线程优先级运行。如果您创建了一个并发操作，并因此重写了start方法，那么您必须自己配置线程优先级。
 
#### 设置一个完成块
在OS X v10.6及更高版本中，一个操作可以在其主任务执行完成时执行一个完成块。您可以使用完成块来执行不属于主任务的任何工作。例如，您可以使用此块通知感兴趣的客户机操作本身已经完成。并发操作对象可能使用此块生成其最终的KVO通知。

要设置一个完成块，使用NSOperation的setCompletionBlock:方法。传递给该方法的块应该没有参数和返回值。

### 操作对象的实现技巧
尽管操作对象很容易实现，但是在编写代码时应该注意几件事。下面几节描述了在为操作对象编写代码时应该考虑的因素。
 
#### 管理操作对象中的内存
下面几节描述操作对象中良好内存管理的关键元素。有关Objective-C程序中内存管理的一般信息，请参阅高级内存管理编程指南。
 
#### 避免每个线程存储
尽管大多数操作都在线程上执行，但对于非并发操作，该线程通常由操作队列提供。如果一个操作队列为您提供了一个线程，那么您应该认为该线程由该队列拥有，而不是由您的操作触及。具体来说，永远不要将任何数据与不是您自己创建或管理的线程关联。由操作队列管理的线程进出取决于系统和应用程序的需要。因此，在使用每个线程存储的操作之间传递数据是不可靠的，而且很可能失败。

对于操作对象，在任何情况下都不应该使用每线程存储。初始化操作对象时，应该为该对象提供完成其工作所需的一切。因此，操作对象本身提供了所需的上下文存储。所有传入和传出的数据都应该存储在那里，直到可以将其集成回应用程序或不再需要。
 
#### 根据需要保持对操作对象的引用
仅仅因为操作对象是异步运行的，您不应该假设您可以创建它们并忘记它们。它们仍然只是对象，由您来管理代码所需的对它们的任何引用。如果您需要在操作完成后从操作中检索结果数据，这一点尤其重要。

应该始终保持自己对操作的引用的原因是，以后可能没有机会向队列请求对象。队列尽一切努力尽可能快地调度和执行操作。在许多情况下，队列几乎在添加后立即开始执行操作。当您自己的代码返回到队列以获取对操作的引用时，该操作可能已经完成并从队列中删除。
 
#### 处理错误和异常
因为操作本质上是应用程序中的离散实体，所以它们负责处理出现的任何错误或异常。在OS X v10.6及更高版本中，NSOperation类提供的默认启动方法不会捕获异常。(在OS X v10.5中，start方法确实捕获和抑制异常。)您自己的代码应该总是直接捕获和抑制异常。它还应该检查错误代码，并根据需要通知应用程序的适当部分。如果替换了start方法，则必须同样地捕获自定义实现中的任何异常，以防止它们离开底层线程的范围。

你应该准备好处理以下类型的错误情况:

检查和处理UNIX errno风格的错误代码。
检查方法和函数返回的显式错误代码。
捕获由您自己的代码或其他系统框架抛出的异常。
捕获NSOperation类本身抛出的异常，它在以下情况下抛出异常:
当操作还没有准备好执行，但调用了它的start方法时
当操作正在执行或完成时(可能是因为它被取消了)，并且再次调用它的start方法
尝试将完成块添加到已执行或已完成的操作时
当您试图检索取消的NSInvocationOperation对象的结果时
如果您的自定义代码确实遇到了异常或错误，您应该采取必要的步骤将该错误传播到应用程序的其余部分。NSOperation类没有提供显式的方法来将错误结果代码或异常传递到应用程序的其他部分。因此，如果这些信息对应用程序很重要，则必须提供必要的代码。
 
### 确定操作对象的适当范围
尽管可以向操作队列中添加任意数量的操作，但这样做通常是不切实际的。像任何对象一样，NSOperation类的实例也会消耗内存，并且有实际的执行成本。如果每个操作对象只做少量的工作，而您创建了成千上万个操作对象，那么您可能会发现调度操作的时间比实际工作的时间要多。如果您的应用程序已经受到内存限制，那么您可能会发现内存中有成千上万个操作对象可能会进一步降低性能。

有效使用操作的关键是在需要做的工作量和保持计算机繁忙之间找到适当的平衡。试着确保您的操作完成了合理的工作量。例如，如果您的应用程序创建了100个操作对象，以对100个不同的值执行相同的任务，那么可以考虑创建10个操作对象，每个操作对象处理10个值。

您还应该避免同时向队列中添加大量操作，或者避免连续向队列中添加操作对象的速度快于它们的处理速度。与其在队列中充斥操作对象，不如批量创建这些对象。当一个批处理执行完成时，使用一个完成块告诉应用程序创建一个新的批处理。当您有很多工作要做时，您希望用足够多的操作填充队列，以使计算机保持忙碌，但又不希望一次创建太多操作，从而导致应用程序耗尽内存。

当然，您创建的操作对象的数量以及在每个操作对象中执行的工作量是可变的，完全取决于您的应用程序。您应该经常使用工具，如工具，以帮助您在效率和速度之间找到适当的平衡。有关Instruments和可用于收集代码度量的其他性能工具的概述，请参见性能概述。
 
### 使用操作对象

#### 向操作队列中添加操作
到目前为止，执行操作最简单的方法是使用操作队列，它是NSOperationQueue类的一个实例。应用程序负责创建和维护它打算使用的任何操作队列。应用程序可以有任意数量的队列，但是在给定的时间点执行多少操作是有实际限制的。操作队列与系统一起工作，将并发操作的数量限制为适合可用内核和系统负载的值。因此，创建额外的队列并不意味着可以执行额外的操作。
要创建一个队列，你在应用程序中分配它，就像你分配任何其他对象一样:
 `NSOperationQueue* aQueue = [[NSOperationQueue alloc] init];`
要向队列添加操作，可以使用addOperation:方法。在OS X v10.6及更高版本中，您可以使用addOperations:waitUntilFinished:方法添加操作组，也可以使用addOperationWithBlock:方法直接将块对象添加到队列中(没有相应的操作对象)。每个方法都对一个(或多个)操作进行排队，并通知队列应该开始处理这些操作。在大多数情况下，操作将在添加到队列后不久执行，但操作队列可能会由于以下任何原因而延迟队列操作的执行。具体来说，如果排队的操作依赖于其他尚未完成的操作，则可能会延迟执行。如果操作队列本身被挂起或已经在执行其最大并发操作数，则执行也可能被延迟。下面的示例展示了向队列添加操作的基本语法。
 ```
 [aQueue addOperation:anOp]; // Add a single operation
[aQueue addOperations:anArrayOfOps waitUntilFinished:NO]; // Add multiple operations
[aQueue addOperationWithBlock:^{
   /* Do something. */
}];
 ```
**注意:**
在将操作对象添加到队列之前，应该对其进行所有必要的配置和修改，因为一旦添加，操作可能在任何时候运行，此时更改可能为时已晚，无法产生预期的效果。

尽管NSOperationQueue类是为并发执行操作而设计的，但是可以强制单个队列一次只运行一个操作。setMaxConcurrentOperationCount:方法允许您配置操作队列对象的最大并发操作数。将值1传递给该方法将导致队列一次只执行一个操作。虽然一次只能执行一个操作，但执行顺序仍然取决于其他因素，例如每个操作的准备情况及其分配的优先级。因此，串行操作队列不能提供与Grand Central dispatch中的串行调度队列完全相同的行为。如果操作对象的执行顺序对您很重要，那么在将操作添加到队列之前，应该使用依赖关系来确定该顺序。有关配置依赖项的信息，请参见配置互操作依赖项。

有关使用操作队列的信息，请参见NSOperationQueue类参考。有关串行调度队列的详细信息，请参见创建串行调度队列。
 
#### 手动执行操作
尽管操作队列是运行操作对象最方便的方式，但也可以在没有队列的情况下执行操作。但是，如果选择手动执行操作，则应该在代码中采取一些预防措施。特别是，操作必须准备好运行，并且必须始终使用其start方法启动它。

在操作的isReady方法返回YES之前，不认为操作能够运行。isReady方法被集成到NSOperation类的依赖管理系统中，以提供操作的依赖状态。只有当其依赖项被清除时，操作才可以开始执行。

手动执行操作时，应始终使用start方法开始执行。您可以使用这个方法，而不是main方法或其他方法，因为start方法在实际运行您的自定义代码之前会执行几次安全检查。特别是，默认的启动方法会生成操作正确处理依赖项所需的KVO通知。如果您的操作已经被取消，此方法还正确地避免执行该操作，如果您的操作还没有实际准备好运行，则抛出异常。

如果应用程序定义了并发操作对象，还应该考虑在启动它们之前调用操作的isConcurrent方法。在此方法返回NO的情况下，您的本地代码可以决定是在当前线程中同步执行操作，还是先创建一个单独的线程。然而，实现这种检查完全取决于您。

清单2-8显示了在手动执行操作之前应该执行的检查类型的简单示例。如果该方法返回NO，您可以安排一个计时器并在稍后再次调用该方法。然后，您将继续重新调度计时器，直到方法返回YES，这可能是因为操作被取消了。
```
- (BOOL)performOperation:(NSOperation*)anOp
{
   BOOL        ranIt = NO;
 
   if ([anOp isReady] && ![anOp isCancelled])
   {
      if (![anOp isConcurrent])
         [anOp start];
      else
         [NSThread detachNewThreadSelector:@selector(start)
                   toTarget:anOp withObject:nil];
      ranIt = YES;
   }
   else if ([anOp isCancelled])
   {
      // If it was canceled before it was started,
      //  move the operation to the finished state.
      [self willChangeValueForKey:@"isFinished"];
      [self willChangeValueForKey:@"isExecuting"];
      executing = NO;
      finished = YES;
      [self didChangeValueForKey:@"isExecuting"];
      [self didChangeValueForKey:@"isFinished"];
 
      // Set ranIt to YES to prevent the operation from
      // being passed to this method again in the future.
      ranIt = YES;
   }
   return ranIt;
}

```
#### 取消操作
一旦添加到操作队列中，操作对象实际上就属于该队列，不能被删除。退出操作队列的唯一方法是取消它。您可以通过调用单个操作对象的cancel方法来取消它，也可以通过调用队列对象的cancelallooperations方法来取消队列中的所有操作对象。

只有在确定不再需要时才应该取消操作。发出取消命令将操作对象置于“已取消”状态，这将阻止它运行。因为一个被取消的操作仍然被认为是“完成的”，依赖于它的对象会收到适当的KVO通知来清除该依赖。因此，更常见的做法是取消所有排队操作以响应一些重要事件，比如应用程序退出或用户特别请求取消，而不是有选择地取消操作。
 
#### 等待操作完成
为了获得最佳性能，您应该将操作设计为尽可能异步的，从而使应用程序在操作执行时可以自由地执行额外的工作。如果创建操作的代码也处理该操作的结果，你可以使用NSOperation的waitUntilFinished方法来阻止该代码，直到操作完成。不过，一般来说，如果可以的话，最好避免调用这个方法。阻塞当前线程可能是一个方便的解决方案，但它确实在代码中引入了更多的序列化，并限制了并发性的总量。

**重要提示:永远不要等待应用程序主线程的操作。只能从次要线程或另一个操作执行此操作。阻塞主线程会阻止应用程序响应用户事件，并可能使应用程序看起来没有响应。**

除了等待单个操作完成，你还可以通过调用NSOperationQueue的waitUntilAllOperationsAreFinished方法来等待队列中的所有操作。当等待整个队列完成时，请注意应用程序的其他线程仍然可以向队列添加操作，从而延长等待时间。
 
#### 暂停和恢复队列
如果您想对操作的执行发出临时暂停，可以使用setSuspended:方法暂停相应的操作队列。挂起队列不会导致已经执行的操作在任务中间暂停。它只是阻止新操作被调度执行。您可以挂起队列以响应用户暂停任何正在进行的工作的请求，因为预期用户最终可能希望恢复该工作。
 