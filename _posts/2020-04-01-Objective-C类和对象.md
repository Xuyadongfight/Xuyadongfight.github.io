---
layout: post
title: Objective-c类和对象
subtitle: 类和对象
categories: iOS
tags: [元类,类,对象]
---
#Objective-c
面向对象的三个基本特征是**封装**，**继承**，**多态**。那么类的结构应该是什么样子的那？
**封装** 
封装的具体表现可以理解为对多个具有相同特点的对象，将它们的相同特点封装为类。这些相同的特点可以认为就是类的成员变量，方法，以及类所遵循的协议。
**继承** 
如何实现类的继承，显然实现类的继承，那么子类中必然包含父类的信息。可以想象子类中必然含有指向父类的指针。
**多态**
多态是指不同的子类在继承父类后都分别重写了父类方法。 虽然继承自同一脉，但是它们方法的表现却各不相同。 即所谓的：多态是同一个行为具有多个不同表现形式或形态的能力。其实简单来说就是继承自同一个父类的不同子类，在调用相同的方法时，产生的行为是不一样的就称之为多态。
**类的结构可能是什么样的**
```
MyClass{
superClass;  //实现继承功能，指向父类
members;  //实现封装的成员变量数组
methods;  //实现封装的方法数组
protocols;  //实现封装的协议数组
}
```
**对象的结构可能是什么样的**
```
MyObject{
class; //指向对象所属的类就可以了
}
```
看完自己定义的可能的对象的结构和类的结构。那么我们再来看看在Objective-C中对象和类的实际结构是什么样的。
**实际的类结构**
![IMAGE](/assets/images/resources/5942810445279A99826A98F7EEEAC072.jpg)
我们先忽略这个`objc_class : objc_object`的继承关系。看起来好像除了有superClass指向父类的东西之外，其它的成员变量数组，方法数组等都不存在啊。别急，我们看看`bits`和那个返回的`data`究竟是什么。
![IMAGE](/assets/images/resources/255B80F5BBE6A3314FC30EE7BDB07F77.jpg)
可以看到这个data方法仅仅只是将bits做了一下按位与的操作。就直接将其结果转为一个指向`class_rw_t`结构的指针。这个结构又是什么样的那。
![IMAGE](/assets/images/resources/F9A1BCFFC7AEE64D4C8F39CA60687B4C.jpg)
等等，我们好像看到了熟悉的东西。`methods`，`properties`，`protocols`。这不就是我们觉得类中应该存在的东西吗。当然了，具体还是有一些不同的，但在这里已经足够了。这个类的结构好像跟我们自己所设计的差不多吗。
**实际的对象的结构**
![IMAGE](/assets/images/resources/E01F2E66D299740B5E4A64B8E8FFA667.jpg)
看起来就一个`isa_t`类型的值吗，`isa_t`又是什么样的那。
![IMAGE](/assets/images/resources/E8EB9019B94018F0DD7E1F652F3C18E4.jpg)
一个联合体。我们知道联合体中的类型是互斥的。某个时刻只能表示其中的一种类型。不出我们所料。其中的一种是我们所期待的指向类的东西
`Class cls`
看起来，我们初步所设计的类和对象的结构都蛮符合实际结构的。那么我们缺少的东西是什么，或者说实际的结构和我们所想的结构的差别又是因为什么原因这样做的那。当然我没法一一把其中的差别及原因说出来。但是可以试着说说其中几种差别的我的看法。

### 1.我们怎么表示一个类及类方法
我们知道类是对象的模板，我们经常使用一个类来创建一个这个类的实例对象。但是如果有些地方我们需要使用的不是对象而是类的时候应该怎么处理那，那些类方法和类属性应该存储在什么地方那。如果直接将这些存贮在类的结构中，好像这些类就变的不纯粹了，因为类应该是相同对象的特征的集合。那么既然对象的方法和成员变量存储在类中，可不可以在创建另一个类来存储类的变量和方法那。这个存储类变量和方法的类我们称之为元类（meta class）。是时候祭出那张图了。
![IMAGE](/assets/images/resources/2AC20B7CD03D8C3855A6BC083C5DF8CA.jpg)


看看虚线isa的指向，对象的isa指向类，类的isa指向元类，元类的isa指向根元类，根元类的isa指向自身。
这样处理的好处就是，结构分明很清楚，对象的方法和成员变量去类中查找，类的成员变量和方法去元类中查找。当然元类是没有成员变量和方法的。
在看看实线superclass的指向。
这里唯一要注意的是根元类的superclass指向了根类，根类的superclass指向了空。
为什么根元类的superclass要指向根类。因为根类已经实现了一系列的运行时方法。如果根元类的superclass也指向nil的话，那么还要在给根元类重新实现相同的运行时方法。这显然不符合我们编程时想尽量复用的思路。

### 2.为什么根元类的superclass指向的是根类，而不是nil?
在Objective-C中实例变量和实例方法是由对象的类定义的。类也是对象，因此它是元类的实例。所以isa的指向其实是说明某个对象是谁的实例。
类方法只是在类对象上调用的方法，因此类的类方法必须在其元类中定义为实例方法。又因为不同的类可以有不同的类方法，所以每个类都必须有自己单独的元类。类和元类总是成对创建的。这也是为什么运行时方法`objc_allocateClassPair`和`objc_registerClassPair`这两个分别创建和注册类方法中的pair的来历。元类没有名称，但是指向任何类对象的指针都可以用泛型类型class引用。因为类方法是通过继承来实现继承的。所以元类必须遵循与类并行的继承关系。根类除外。根类的父类为nil，而根元类的父类为根类。
根元类继承自根类，这确保了所有类对象最终都是根类的实例，这样就可以在类对象本身上使用根类的实例方法。

### 3.为什么元类的isa都指向根元类，且根元类的isa指向自身？
![IMAGE](/assets/images/resources/FE75F14B0064CD1EADC0D4F8535E0EC7.jpg)
因为所有的元类对象没有不同的行为，即元类的共同方法都是一样的（你没法对元类添加类方法）。不同的类的类方法是存储在不同的元类中的，但元类的方法都是一样的。所以元类都是根元类的实例，因此，根元类是其自身的实例。这样做的原因是所有的元类都继承自根类，所以他们也必须继承根类的类方法。

### 4.isMemberOfClass和isKindOfClass的区别?
isMemberOfClass比较的是消息接收者是否是一个类的实例。具体点就是比较的是isa的指向。再具体一点就是消息接收者的isa是否是指向你所传入的那个类或者元类。
isKindOfClass比较的不仅是isMemberOfClass的功能，它还比较了消息接收者的superclass指向是否指向传入的那个类或者元类。isa的比较和superclass的比较，任意一个为真则结果就是真。注意要获取某个元类使用objc_getMetaClass方法。
