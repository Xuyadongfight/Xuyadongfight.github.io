---
layout: post
title: Swift的初始化
subtitle: Swift的初始化
categories: iOS
tags: [Swift,初始化]
---
## 初始化定义
初始化是为类、结构体或者枚举准备实例的过程。这个过需要给实例里的每一个存储属性设置一个初始值并且在新实例可以使用之前执行任何其他所必须的配置或初始化。在创建类和结构体的实例时必须为所有的存储属性设置一个合适的初始值。存储属性不能遗留在不确定的状态中。你可以在初始化器里为存储属性设置一个初始值，或者通过分配一个默认的属性值作为属性定义的一部分。

### 初始化器
初始化器在创建特定类型的实例时被调用。在这个简单的形式中，初始化器就像一个没有形式参数的实例方法，使用 init 关键字来写：
```
    init(){
        
    }
```
初始化必须为存储属性设置一个合适的初始值。存储属性在初始化后不能在一个不确定的状态中。可以通过给存储属性在声明时设置默认值或者在初始化的时候给属性设置一个值。但是初始化后所有存储属性都必须是在一个确定的状态。即都是有值的。如果属性为可选类型的。则属性默认为nil。
属性分为计算属性和存储属性。初始化需要保证在初始化完成之后。所有的存储属性是一个确定的状态。如果不是可选类型的存储属性则必须要一个确定的值。这个值可用是在声明的时候给一个默认值或者在初始化方法里给一个值。对于常量类型也是如此。对有可选类型的存储属性。因为默认就会设为nil。所以可以不用专门声明时候设值或者初始化的时候设置。但是要注意的是如果是常量类型的可选类型。则要么在声明时候赋值，要么在初始化时候赋值。否则会报编译错误。因为如果自动给常量类型赋值为nil的话。初始化完成之后你就无法改变它的值了。一个不能改变的值为nil的常量存储属性没有意义。

### 默认初始化器
Swift为给所有属性提供了默认值的。且没有提供初始化器的结构体或类提供了一个默认初始化器。这个默认初始化器只是简单的创造了一个所有属性都是默认值的新实例。要注意的是没有初始化器的类包括没有从父类继承初始化器。如果已经从父类继承了初始化器。则表面这个类已经有了初始化器。则系统不会为其提供默认初始化器。
那么系统会提供默认初始化器的原则就是:
1. 自身没有提供初始化器，也没有从父类继承的初始化器
2. 自身所有的存储属性都有默认值，或者是可选类型的属性。


### 值类型的初始化器
#### 默认初始化器
如果值类型没有提供初始化器且每个存储属性都有一个默认值或者存储属性是可选的。则Swift会为其提供一个默认的初始化器。
```
struct Struct_1 {
    var name = ""
    var age : Int? //可选类型的存储属性可以当做默认值为nil的属性
}
let s1_1)//默认初始化器
let s1_2)//成员初始化器
```

#### 成员初始化器
如果结构体类型中没有任何自定义的初始化器，它将会获得一个成员初始化器。同默认初始化器不同的是，不管成员的存储属性有没有默认值。结构体都会接收成员初始化器。即结构体的成员初始化器的条件为：
1. 自身没有初始化器。因为结构体不能继承，故不用考虑是否继承了父类的初始化器
2. 自身的存储属性不管有没有默认值都会有一个成员初始化器。如果所有成员都有默认值，则会额外存在一个默认初始化器，反之则没有默认初始化器。
```
struct Struct_2 {
    var name = ""
    var age : Int //因为这个存储属性没有默认值所以没有提供默认初始化器
}
let s2_1)//成员初始化器
let s2_2)//成员初始化器
```
#### 初始化器委托
初始化器可以调用其它初始化器来执行部分实例的初始化。这个过程就是所谓的初始化器委托，避免了多个初始化器里的冗余代码。
初始化器委托的运作，已经运行哪些形式的委托。这些规则对于值类型和类类型是不同的。值类型（结构体和枚举）不支持继承，所以他们的初始化器的委托过程相对简单。因为它们只能提供它们自己作为另一个初始化器的委托。而类因为可以继承，这就意味着类有额外的责任来确保他们继承的所有存储属性在初始化之后都有一个合适的值。
```
struct Struct_3 {
    var name = ""
    var age : Int
    init(age:Int){ //自定义了初始器方法
        self.age = age
    }
    init(delegate:Int){
        self.init(age: delegate)//因为使用了其它初始化器来执行部分实例的初始化。（初始化器委托）
    }
}
let s3)
```
**注意:一旦自己使用init关键字自定义了初始器方法。则Swift不会提供默认初始化器和成员初始化器了**

#### 值类型初始化器判断
1. 没有自定义初始化器的时候。Swift会为值类型提供一个成员初始化器。如果所有的存储属性都有默认值。则还会额外提供一个默认初始化器（可以将可选类型的存储属性理解为一个默认值为nil的属性即是有默认值的）
2. 当有自定义初始化器时候。Swift既不会提供默认初始化器，也不会提供成员初始化器。


### 类类型的初始化器
所有类的存储属性——包括从它的父类继承的所有属性——都必须在初始化期间分配初始值。Swift为类类型定义了两种初始化器以确保所有的存储属性接收一个初始值。这些就是所谓的指定初始化器和便捷初始化器

#### 指定初始化器
指定初始化器是类的主要初始化器。指定的初始化器可以初始化所有那个类引用的属性并且调用合适的父类初始化器来继续这个初始化过程给父类链。类偏向于少量指定初始化器，并且一个类通常只有一个指定初始化器。指定初始化器是初始化开始并持续初始化过程到父类链的“传送”点。每个类至少得有一个指定初始化器。指定初始化器语法
```
init(parameters) {
    statements
}
```

#### 便捷初始化器
便捷初始化器是次要的，为一个类支持初始化器。你可以在相同的类里定义一个便捷初始化器来调用一个指定的初始化器作为便捷初始化器来给指定初始化器设置默认形式参数。你也可以为具体的使用情况或输入的值类型定义一个便捷初始化器从而创建这个类的实例。
如果你的类不需要便捷初始化器你可以不提供它。在为通用的初始化模式创建快捷方式以节省时间或者类的初始化更加清晰明了的时候使用便捷初始化器。
```
convenience init(parameters) {
    statements
}
```

#### 类类型的初始化器委托
为了简化指定和便捷初始化器之间的调用关系，Swift 在初始化器之间的委托调用有下面的三个规则:
1. 指定初始化器必须从它的直系父类调用指定初始化器。
2. 便捷初始化器必须从相同的类里调用另一个初始化器。
3. 便捷初始化器最终必须调用一个指定初始化器。

简单记忆的规则方法如下:
* 指定初始化器必须总是向上委托
* 便捷初始化器必须总是横向委托，并且最终要调用一个指定初始化器。

![IMAGE](/assets/images/resources/21F2CE2C995E7AE7EA00FAB13566070E.jpg)
如图所示，父类包含一个指定初始化器和两个便捷初始化器。一个便捷初始化器调用另一个便捷初始化器，而后者又调用了指定初始化器。这满足了上边的规则2和规则3。父类本身没有其他父类，所以规则1不适用。
这个图中的子类有两个指定初始化器和一个便捷初始化器。便捷初始化器必须调用这两个指定初始化器之一，因为它只能从同一个类中调用初始化器。这满足了上边的规则2和规则3。两个指定初始化器又必须从父类调用一个指定初始化器，这满足了上边所说的规则1。

#### 类初始化的过程:两段式初始化
Swift 的类初始化是一个两段式过程。在第一个阶段，每一个存储属性被引入类分配了一个初始值。一旦每个存储属性的初始状态被确定，第二个阶段就开始了，每个类都有机会在新的实例准备使用之前来定制它的存储属性。

两段式初始化过程的使用让初始化更加安全，同时在每个类的层级结构给与了完备的灵活性。两段式初始化过程可以防止属性值在初始化之前被访问，还可以防止属性值被另一个初始化器意外地赋予不同的值。

Swift编译器执行四种有效的安全检查来确保两段式初始化过程能够顺利完成：
1. 安全检查1
指定初始化器必须保证在向上委托给父类初始化器之前，其所在类引入的所有属性都要初始化完成。
如上所述，一个对象的内存只有在其所有储存型属性确定之后才能完全初始化。为了满足这一规则，指定初始化器必须保证它自己的属性在它上交委托之前先完成初始化。

2. 安全检查2
指定初始化器必须先向上委托父类初始化器，然后才能为继承的属性设置新值。如果不这样做，指定初始化器赋予的新值将被父类中的初始化器所覆盖。

3. 安全检查3
便捷初始化器必须先委托同类中的其它初始化器，然后再为任意属性赋新值（包括同类里定义的属性）。如果没这么做，便捷构初始化器赋予的新值将被自己类中其它指定初始化器所覆盖。

4. 安全检查4
初始化器在第一阶段初始化完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用 self 作为值。
直到第一阶段结束类实例才完全合法。属性只能被读取，方法也只能被调用，直到第一阶段结束的时候，这个类实例才被看做是合法的。
以下是两段初始化过程，基于上述四种检查的流程：

**阶段1:**
* 指定或便捷初始化器在类中被调用；
* 为这个类的新实例分配内存。内存还没有被初始化；
* 这个类的指定初始化器确保所有由此类引入的存储属性都有一个值。现在这些存储属性的内存被初始化了；
* 指定初始化器委托父类的初始化器为其存储属性执行相同的任务；
* 这个调用父类初始化器的过程将沿着初始化器链一直向上进行，直到到达初始化器链的最顶部；
* 一旦达了初始化器链的最顶部，在链顶部的类确保所有的存储属性都有一个值，此实例的内存被认为完全初始化了，此时第一阶段完成。

**阶段2:**
* 从顶部初始化器往下，链中的每一个指定初始化器都有机会进一步定制实例。初始化器现在能够访问self并且可以修改它的属性，调用它的实例方法等等；
* 最终，链中任何便捷初始化器都有机会定制实例以及使用self

### 初始化器的继承和重写
不像在 Objective-C 中的子类，Swift的子类不会默认继承父类的初始化器。Swift的这种机制防止父类的简单初始化器被一个更专用的子类继承并被用来创建一个没有完全或错误初始化的新实例的情况发生。
如果你想自定义子类来实现一个或多个和父类相同的初始化器，你可以在子类中为那些初始化器提供定制的实现。
当你写的子类初始化器匹配父类指定初始化器的时候，你实际上可以重写那个初始化器。因此，在子类的初始化器定义之前你必须写 override 修饰符。如同默认初始化器所描述的那样，即使是自动提供的默认初始化器你也可以重写。作为一个重写的属性，方法或下标脚本， override 修饰符的出现会让 Swift来检查父类是否有一个匹配的指定初始化器来重写，并且验证你重写的初始化器已经按照意图指定了形式参数。
**注意：** 当重写父类指定初始化器时，你必须写 override 修饰符，就算你子类初始化器的实现是一个便捷初始化器。
相反，如同上边类类型的初始化器委托所描述的规则那样，如果你写了一个匹配父类便捷初始化器的子类初始化器，父类的便捷初始化器将永远不会通过你的子类直接调用。因此，你的子类不能(严格来讲)提供父类初始化器的重写。当提供一个匹配的父类便捷初始化器的实现时，你不用写 override 修饰符。

### 初始化器的自动继承
如上所述，子类默认不会继承父类初始化器。总之，在特定的情况下父类初始化器是可以被自动继承的。实际上，这意味着在许多场景中你不必重写父类初始化器，只要可以安全操作，你就可以毫不费力地继承父类的初始化器。
假设你为你子类引入的任何新的属性都提供了默认值，请遵守以下2个规则：
* 规则1
如果你的子类没有定义任何指定初始化器，它会自动继承父类所有的指定初始化器。
* 规则2
如果你的子类提供了所有父类指定初始化器的实现——要么是通过规则1继承来的，要么通过在定义中提供自定义实现的——那么它自动继承所有的父类便捷初始化器。就算你的子类添加了更多的便捷初始化器，这些规则仍然适用。

### 类类型的初始化器总结
1. 类类型只有两种初始化器。指定初始化器和便捷初始化器。指定初始化器是必须有一个的。便捷初始化器不是必须的。当一个类的所有存储属性都有默认值（可以将可选类型理解为默认值为nil）。且没有从父类继承的初始化器时。Swift会为其提供一个默认初始化器。这个初始化器就是这个类的指定初始化器。

```
class Class_default{
    var name : String? //可选类型 默认值为nil
    var age : Int = 10 //Int类型 默认值为10
}
let class_default)//没有定义初始化器，且没有继承的初始化器。且所有存储属性有默认值。故Swift提供一个默认初始化器作为类的指定初始化器
```

2. 类的指定初始化器和便捷初始化器间的关系（同一个类之间 不涉及父类）
* 便捷初始化器必须从相同类里调用另一个初始化器，另一个初始化器可以是便捷初始化器,也可以是指定初始化器
* 便捷初始化器最终必须调用一个指定初始化器。也就是说便捷初始化器的方法最后一点会跳到一个指定初始化器里面

3. 类的初始化器的自动继承
* 如果子类没有引入任何新的属性或者任何新的属性都有一个默认值。如果你的子类没有定义任何指定初始化器，它会自动继承父类所有的指定初始化器
* 如果你的子类提供了所有父类指定初始化器的实现。包括从父类继承来的指定初始化器和自定义的指定初始化器。那么它自动继承所有的父类的便捷初始化器。

4. 初始化器的重写
当你的子类初始化器匹配父类的指定初始化器的时候，你时间上可以重新那个初始化器。因此，在子类的初始化器之前你必须写override修饰符。即使是自动提供的默认初始化器也可以重写。override修饰符会让Swift检查父类是否有一个匹配的指定初始化器来重写，并且验证你重写的初始化器已经按照意图指定了形式参数。当重写父类指定初始化器时，你必须写override修饰符，就算你子类初始化器的实现是一个便捷初始化器。
相反，如同类类型的初始化器委托所描述的规则那样，如果你写了一个匹配父类便捷初始化器的子类初始化器，父类的便捷初始化器将永远不会通过你的子类直接调用。因此，你的子类不能(严格来讲)提供父类初始化器的重写。当提供一个匹配的父类便捷初始化器的实现时，你不用写 override 修饰符。

### 必要初始化器
在类的初始化器前添加required修饰符来表明所有该类的字类都必须实现该初始化器:
```
class SomeClass {
    required init() {
        // initializer implementation goes here
    }
}
```
当子类重写父类的必要初始化器时，必须在子类的初始化器前同样添加 required 修饰符以确保当其它类继承该子类时，该初始化器同为必要初始化器。在重写父类的必要初始化器时，不需要添加 override 修饰符：
```
class SomeSubclass: SomeClass {
    required init() {
        // subclass implementation of the required initializer goes here
    }
}
```
**注意:如果子类继承的初始化器能够满足需求，则你无需显式地在子类中提供必要初始化器的实现。**
