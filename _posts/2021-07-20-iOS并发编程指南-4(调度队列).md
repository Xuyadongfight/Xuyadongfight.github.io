---
layout: post
title: 并发编程-4(调度队列)
subtitle: 并发编程
categories: iOS
tags: [并发]
---
## 调度队列
中央调度(GCD)调度队列是执行任务的强大工具。调度队列允许您针对调用者异步或同步地执行任意代码块。您可以使用调度队列来执行过去在单独线程上执行的几乎所有任务。调度队列的优点是它们使用起来更简单，在执行这些任务时比相应的线程代码更有效。

## 关于调度队列
调度队列是在应用程序中异步并发执行任务的一种简单方法。任务只是应用程序需要执行的一些工作。例如，您可以定义一个任务来执行一些计算、创建或修改数据结构、处理从文件中读取的一些数据或任何数量的事情。通过在函数或块对象中放置相应的代码并将其添加到调度队列中来定义任务。

调度队列是一种类似对象的结构，用于管理提交给它的任务。所有调度队列都是先进先出的数据结构。因此，添加到队列中的任务总是按照添加它们时的相同顺序启动。GCD自动为您提供了一些调度队列，但是您可以为特定目的创建其他调度队列。表3-1列出了应用程序可用的调度队列类型以及如何使用它们。
![IMAGE](/assets/images/resources/88AC43206E61AB6EBA2B05B4F1C10A8C.jpg)

在向应用程序添加并发性时，调度队列比线程提供了几个优势。最直接的优点是工作队列编程模型的简单性。使用线程，您必须为要执行的工作以及线程本身的创建和管理编写代码。分派队列使您可以专注于实际想要执行的工作，而不必担心线程的创建和管理。相反，系统为您处理所有线程的创建和管理。其优点是，该系统能够比任何单一应用程序更有效地管理线程。系统可以根据可用资源和当前系统条件动态地扩展线程数。此外，系统通常能够比您自己创建线程更快地开始运行您的任务。

尽管您可能认为为分派队列重写代码很困难，但为分派队列编写代码通常比为线程编写代码更容易。编写代码的关键是设计自包含且能够异步运行的任务。(对于线程和分派队列都是如此。)然而，调度队列的优势在于可预测性。如果有两个任务访问相同的共享资源，但运行在不同的线程上，那么任何一个线程都可以先修改资源，您将需要使用锁来确保两个任务不会同时修改该资源。使用调度队列，可以将两个任务添加到串行调度队列中，以确保在任何给定时间只有一个任务修改资源。这种类型的基于队列的同步比锁更有效，因为锁在有争用和无争用的情况下总是需要昂贵的内核陷阱，而调度队列主要在应用程序的进程空间中工作，只有在绝对必要时才调用内核。

尽管您指出在串行队列中运行的两个任务不会并发运行是正确的，但您必须记住，如果两个线程同时获得一个锁，那么线程提供的任何并发性都将丢失或显著减少。更重要的是，线程模型需要创建两个线程，这两个线程同时占用内核和用户空间内存。分派队列不会为它们的线程支付相同的内存代价，并且它们所使用的线程将保持繁忙而不是阻塞。
关于调度队列的其它的关键点包括:
* 调度队列相对于其他调度队列并发地执行它们的任务。任务的序列化仅限于单个调度队列中的任务。
* 系统决定在任意时刻执行的任务总数。因此，在100个不同队列中有100个任务的应用程序可能无法同时执行所有这些任务(除非它有100个或更多有效核心)。
* 在选择启动哪个新任务时，系统会考虑队列优先级。有关如何设置串行队列的优先级的信息，请参见为队列提供清理功能。
* 队列中的任务在被添加到队列时必须已准备好执行。(如果您以前使用过Cocoa操作对象，请注意此行为与模型操作的使用不同。)
* 私有分派队列是引用计数对象。除了在您自己的代码中保留队列外，还要注意调度源也可以附加到队列并增加其保留计数。因此，您必须确保所有调度源都被取消，并且所有保留调用都与适当的释放调用相平衡。有关保留和释放队列的详细信息，请参见调度队列的内存管理。有关调度源的详细信息，请参见关于调度源。

## 队列相关技术
除了调度队列之外，Grand Central dispatch还提供了几种使用队列来帮助管理代码的技术。表3-2列出了这些技术，并提供了有关它们的更多信息的链接。
![IMAGE](/assets/images/resources/33EE1BED7D1E94632B533E5BD8A1DB40.jpg)

## 使用Blocks实现任务
块对象是一种基于C的语言特性，您可以在C、Objective-C和c++代码中使用它。块使定义一个自包含的工作单元变得容易。虽然它们看起来类似于函数指针，但块实际上是由类似于对象的底层数据结构表示的，由编译器为您创建和管理。编译器将您提供的代码(以及任何相关数据)打包，并将其封装成一种可以存在于堆中并在应用程序中传递的形式。

块的一个关键优势是它们能够使用自己的词法范围之外的变量。在函数或方法中定义块时，该块在某些方面就像传统的代码块一样。例如，一个块可以读取父作用域中定义的变量的值。块访问的变量被复制到堆上的块数据结构中，以便稍后块可以访问它们。当块被添加到调度队列时，这些值通常必须以只读格式保存。然而，同步执行的块也可以使用前面带有__block关键字的变量来将数据返回到父对象的调用范围。

在代码中使用与函数指针使用的语法相似的语法声明块。块和函数指针之间的主要区别是块名称前面有一个插入符号(^)而不是星号(*)。像函数指针一样，您可以向块传递参数并从它接收返回值。
 ```
 int x = 123;
int y = 456;
 
// Block declaration and assignment
void (^aBlock)(int)) {
    printf("%d %d %d\n", x, y, z);
};
 
// Execute the block
aBlock(789);   // prints: 123 456 789
 ```
以下是在设计block时应该考虑的一些内容
* 对于计划使用调度队列异步执行的块，从父函数或方法捕获标量变量并在块中使用它们是安全的。但是，您不应该尝试捕获由调用上下文分配和删除的大型结构或其他基于指针的变量。在执行块时，该指针所引用的内存可能已经消失。当然，自己分配内存(或对象)并显式地将该内存的所有权移交给块是安全的。
* 分派队列复制添加到它们的块，并在执行完成时释放块。换句话说，在将块添加到队列之前，不需要显式地复制它们。
虽然在执行小任务时，队列比原始线程更有效，但创建块并在队列上执行它们仍然有开销。如果一个块做的工作太少，内联执行它可能比分派到队列更便宜。判断一个块是否工作过少的方法是使用性能工具为每个路径收集指标并进行比较。
* 不要相对于底层线程缓存数据，并期望数据可以从不同的块访问。如果同一队列中的任务需要共享数据，则使用调度队列的上下文指针来存储数据。有关如何访问调度队列的上下文数据的详细信息，请参见使用队列存储自定义上下文信息。
* 如果你的块创建了多个Objective-C对象，你可能想要在@autorelease块中包含部分代码来处理这些对象的内存管理。尽管GCD调度队列有自己的自动释放池，但它们不保证这些池何时被耗尽。如果应用程序受到内存限制，创建自己的自动释放池可以让您更定期地为自动释放对象释放内存。

有关块的更多信息，包括如何声明和使用它们，请参阅块编程主题。有关如何向调度队列添加块的信息，请参见向队列添加任务。

## 创建和管理分派队列
在将任务添加到队列之前，必须决定使用哪种类型的队列以及打算如何使用它。分派队列可以串行地或并发地执行任务。此外，如果您心中有队列的特定用途，则可以相应地配置队列属性。下面几节向您展示如何创建分派队列并配置它们以供使用。
 
### 获取全局并发调度队列
当有多个任务可以并行运行时，并发调度队列非常有用。并发队列仍然是队列，因为它按照先进先出的顺序将任务排出队列;然而，并发队列可以在任何先前的任务完成之前将其他任务从队列中取出。并发队列在任何给定时刻执行的实际任务数量都是可变的，并且可以随着应用程序中的条件的变化而动态变化。许多因素会影响并发队列执行的任务数量，包括可用内核的数量、其他进程正在完成的工作量以及其他串行调度队列中任务的数量和优先级。

系统为每个应用程序提供四个并发调度队列。这些队列对于应用程序来说是全局的，仅根据其优先级进行区分。因为它们是全局的，所以不需要显式地创建它们。相反，您可以使用dispatch_get_global_queue函数请求其中一个队列，如下例所示:
 `dispatch_queue_t aQueue);`
 除了获得默认并发队列外，还可以通过向函数传递DISPATCH_QUEUE_PRIORITY_HIGH和DISPATCH_QUEUE_PRIORITY_LOW常量来获得具有高优先级和低优先级的队列，或者通过传递DISPATCH_QUEUE_PRIORITY_BACKGROUND常量来获得后台队列。如您所料，高优先级并发队列中的任务在默认和低优先级队列中的任务之前执行。类似地，默认队列中的任务在低优先级队列中的任务之前执行。
 注意:dispatch_get_global_queue函数的第二个参数为将来扩展保留。目前，您应该始终为这个参数传递0。
 尽管调度队列是引用计数对象，但您不需要保留和释放全局并发队列。因为它们对于应用程序是全局的，所以对这些队列的保留和释放调用将被忽略。因此，您不需要存储对这些队列的引用。只要需要引用其中一个，就可以调用dispatch_get_global_queue函数。
 
### 创建串行调度队列
当您希望任务以特定顺序执行时，串行队列非常有用。串行队列一次只执行一个任务，并且总是从队列头部提取任务。您可以使用串行队列而不是锁来保护共享资源或可变数据结构。与锁不同，串行队列确保任务以可预测的顺序执行。只要异步地将任务提交到串行队列，队列就永远不会死锁。

与为您创建的并发队列不同，您必须显式地创建和管理您想要使用的任何串行队列。您可以为应用程序创建任意数量的串行队列，但应避免仅仅为了同时执行尽可能多的任务而创建大量的串行队列。如果希望并发执行大量任务，请将它们提交到全局并发队列之一。在创建串行队列时，尝试确定每个队列的用途，例如保护资源或同步应用程序的某些关键行为。

清单3-2显示了创建自定义串行队列所需的步骤。dispatch_queue_create函数接受两个参数:队列名称和一组队列属性。调试器和性能工具显示队列名称，以帮助您跟踪任务的执行情况。队列属性为将来使用而保留，应该为NULL。
 ```
 dispatch_queue_t queue;
queue);
 ```
除了您所创建的任何自定义队列之外，系统还会自动创建一个串行队列，并将其绑定到应用程序的主线程。有关获取主线程队列的详细信息，请参见在运行时获取公共队列。
 
### 在运行时获取公共队列
Grand Central Dispatch提供了一些函数，可以让您从应用程序访问几个常见的调度队列:
使用dispatch_get_current_queue函数进行调试或测试当前队列的标识。从块对象内部调用此函数将返回块提交到的队列(并且现在可能正在该队列上运行)。从块外部调用此函数将返回应用程序的默认并发队列。
使用dispatch_get_main_queue函数获取与应用程序主线程关联的串行调度队列。这个队列是为Cocoa应用程序和在主线程上调用dispatch_main函数或配置运行循环(使用CFRunLoopRef类型或NSRunLoop对象)的应用程序自动创建的。
使用dispatch_get_global_queue函数来获取任何共享并发队列。有关详细信息，请参见获取全局并发调度队列。
 
### 调度队列的内存管理
分派队列和其他分派对象是引用计数的数据类型。当您创建一个串行分派队列时，它的初始引用计数为1。您可以使用dispatch_retain和dispatch_release函数根据需要增加或减少引用计数。当队列的引用计数为零时，系统将异步释放该队列。

保留和释放调度对象(如队列)非常重要，以确保它们在使用时仍保留在内存中。与内存管理的Cocoa对象一样，一般的规则是，如果您计划使用传递给代码的队列，则应该在使用它之前保留它，并在不再需要它时释放它。这个基本模式可确保队列在使用期间一直保留在内存中。
注意:您不需要保留或释放任何全局调度队列，包括并发调度队列或主调度队列。任何保留或释放队列的尝试都将被忽略。

即使实现了垃圾收集应用程序，仍然必须保留和释放调度队列和其他调度对象。中央调度不支持回收内存的垃圾收集模型。
 
### 使用队列存储自定义上下文信息
所有调度对象(包括调度队列)都允许将自定义上下文数据与对象关联。要在给定对象上设置和获取此数据，可以使用dispatch_set_context和dispatch_get_context函数。系统不会以任何方式使用您的自定义数据，在适当的时间分配和释放数据取决于您。

对于队列，您可以使用上下文数据来存储指向Objective-C对象或其他数据结构的指针，这些数据结构有助于识别队列或它对代码的预期用途。您可以使用队列的终结器函数在释放上下文数据之前将其从队列中释放(或解除关联)。清单3-3显示了如何编写一个清除队列上下文数据的终结器函数的示例。
 
### 为队列提供清理功能
创建了串行分派队列后，可以附加一个终结器函数，以便在队列被释放时执行任何自定义清理。调度队列是引用计数对象，您可以使用dispatch_set_finalizer_f函数指定当队列的引用计数为零时执行的函数。使用此函数清理与队列关联的上下文数据，并且仅当上下文指针不为NULL时才调用该函数。

清单3-3显示了一个自定义终结器函数和一个创建队列并安装该终结器的函数。队列使用终结器函数释放存储在队列上下文指针中的数据。(代码中引用的myInitializeDataContextFunction和myCleanUpDataContextFunction函数是用于初始化和清理数据结构本身内容的自定义函数。)传递给终结器函数的上下文指针包含与队列关联的数据对象。
 ```
 void myFinalizerFunction(void *context)
{
    MyDataContext* theData)context;
 
    // Clean up the contents of the structure
    myCleanUpDataContextFunction(theData);
 
    // Now release the structure itself.
    free(theData);
}
 
dispatch_queue_t createMyQueue()
{
    MyDataContext*  data);
    myInitializeDataContextFunction(data);
 
    // Create the queue and set the context data.
    dispatch_queue_t serialQueue);
    dispatch_set_context(serialQueue, data);
    dispatch_set_finalizer_f(serialQueue, &myFinalizerFunction);
 
    return serialQueue;
}

 ```
 
## 向队列中添加任务
要执行任务，必须将其分派到适当的分派队列。可以同步或异步分派任务，也可以单独或分组分派任务。一旦进入队列，队列就会负责尽快执行您的任务，给定它的约束条件和队列中已经存在的任务。本节向您展示将任务分派到队列的一些技术，并描述每种技术的优点。
 
### 向队列中添加单个任务
有两种方法将任务添加到队列:异步或同步。在可能的情况下，使用dispatch_async和dispatch_async_f函数进行异步执行比使用同步替代方法更好。当您将块对象或函数添加到队列中时，无法知道该代码何时执行。因此，异步添加块或函数可以让您安排代码的执行，并继续在调用线程中执行其他工作。如果从应用程序主线程调度任务(可能是为了响应某些用户事件)，这一点尤其重要。

尽管您应该尽可能异步地添加任务，但有时仍然需要同步地添加任务以防止竞争条件或其他同步错误。在这些实例中，可以使用dispatch_sync和dispatch_sync_f函数将任务添加到队列中。这些函数阻塞当前的执行线程，直到指定的任务执行完毕。
 
注意:永远不要从计划传递给该函数的同一队列中执行的任务中调用dispatch_sync或dispatch_sync_f函数。这对于保证死锁的串行队列尤其重要，但是对于并发队列也应该避免这种情况。
 
下面的例子展示了如何使用基于块的变量来异步和同步地调度任务:
```
dispatch_queue_t myCustomQueue;
myCustomQueue);
 
dispatch_async(myCustomQueue, ^{
    printf("Do some work here.\n");
});
 
printf("The first block may or may not have run.\n");
 
dispatch_sync(myCustomQueue, ^{
    printf("Do some more work here.\n");
});
printf("Both blocks have completed.\n");

```

### 当一个任务完成时执行一个完成块
根据它们的性质，分派到队列的任务独立于创建它们的代码运行。但是，当任务完成时，您的应用程序可能仍然希望得到该事实的通知，以便它可以合并结果。对于传统的异步编程，您可以使用回调机制来实现这一点，但是对于分派队列，您可以使用完成块。

完成块只是在原始任务结束时分派到队列中的另一段代码。调用代码通常在启动任务时将完成块作为参数提供。任务代码所要做的就是在完成工作时将指定的块或函数提交给指定的队列。

清单3-4显示了使用块实现的平均函数。平均函数的最后两个参数允许调用者指定在报告结果时使用的队列和块。在平均函数计算出它的值之后，它将结果传递给指定的块并将其分派到队列。为了防止队列被过早地释放，关键是要在最初保留该队列，并在完成块被分派后释放它。
 
```
void average_async(int *data, size_t len,
   dispatch_queue_t queue, void (^block)(int))
{
   // Retain the queue provided by the user to make
   // sure it does not disappear before the completion
   // block can be called.
   dispatch_retain(queue);
 
   // Do the work on the default concurrent queue and then
   // call the user-provided block with the results.
   dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
      int avg);
      dispatch_async(queue, ^{ block(avg);});
 
      // Release the user-provided queue when done
      dispatch_release(queue);
   });
}

```

### 并行执行循环迭代
并发分派队列可能提高性能的一个地方是，在其中有一个执行固定次数迭代的循环。例如，假设你有一个For循环，它在每次循环迭代中都做一些工作:
 ```
 for (i) {
   printf("%u\n",i);
}
 ```
如果在每次迭代期间执行的工作与所有其他迭代期间执行的工作不同，并且每个后续循环完成的顺序不重要，那么您可以用调用dispatch_apply或dispatch_apply_f函数来替换循环。这些函数在每次循环迭代时将指定的块或函数提交给队列一次。因此，当分派到并发队列时，可以同时执行多个循环迭代。

在调用dispatch_apply或dispatch_apply_f时，可以指定串行队列或并发队列。传入并发队列允许您同时执行多个循环迭代，这是使用这些函数的最常用方法。虽然使用串行队列是允许的，而且对您的代码来说是正确的，但是使用这样的队列与保留循环相比并没有真正的性能优势。

重要提示:与常规for循环一样，dispatch_apply和dispatch_apply_f函数在所有循环迭代完成后才返回。因此，当从已经在队列上下文中执行的代码中调用它们时，应该非常小心。如果作为参数传递给函数的队列是一个串行队列，并且与执行当前代码的队列相同，那么调用这些函数将导致队列死锁。

因为它们有效地阻塞了当前线程，所以从主线程调用这些函数时也应该小心，因为它们可能会阻止事件处理循环及时响应事件。如果循环代码需要大量的处理时间，您可能希望从不同的线程调用这些函数。
 
展示如何用dispatch_apply语法替换前面的for循环。传递给dispatch_apply函数的块必须包含标识当前循环迭代的单个参数。在执行块时，第一次迭代时该参数的值为0，第二次迭代时为1，依此类推。最后一次迭代的参数值是count - 1，其中count是迭代的总次数。
 ```
 dispatch_queue_t queue);
 
dispatch_apply(count, queue, ^(size_t i) {
   printf("%u\n",i);
});
 ```
 您应该确保您的任务代码在每次迭代中完成了合理数量的工作。与分派到队列的任何块或函数一样，调度代码执行也有开销。如果循环的每次迭代只执行少量的工作，那么调度代码的开销可能会超过将代码调度到队列中所获得的性能好处。如果您在测试期间发现这是正确的，您可以使用跨步来增加在每个循环迭代期间执行的工作量。使用stride，您可以将原始循环的多个迭代组合到一个块中，并按比例减少迭代计数。例如，如果您最初执行100次迭代，但决定使用4的步幅，那么您现在从每个块执行4次循环迭代，并且您的迭代计数为25。有关如何实现跨步的示例，请参见改进循环代码。
 
### 在主线程执行任务
Grand Central Dispatch提供了一个特殊的调度队列，您可以使用它在应用程序主线程上执行任务。该队列是为所有应用程序自动提供的，并且由任何在主线程上设置运行循环(由CFRunLoopRef类型或NSRunLoop对象管理)的应用程序自动排出。如果您没有创建Cocoa应用程序，也不想显式地设置运行循环，那么必须调用dispatch_main函数显式地排出主调度队列。您仍然可以将任务添加到队列中，但如果不调用此函数，这些任务将永远不会执行。

您可以通过调用dispatch_get_main_queue函数来获取应用程序主线程的调度队列。添加到此队列的任务在主线程本身上串行执行。因此，您可以将此队列用作应用程序其他部分正在执行的工作的同步点。
 
### 在任务中使用Objective-C对象
GCD提供了对Cocoa内存管理技术的内置支持，因此您可以在提交给调度队列的块中自由地使用Objective-C对象。每个调度队列维护自己的自动释放池，以确保自动释放的对象在某个时刻被释放;队列不保证何时释放这些对象。

如果您的应用程序内存受限，并且您的块创建了多个自动释放对象，那么创建您自己的自动释放池是确保您的对象及时释放的唯一方法。如果您的块创建了数百个对象，您可能希望创建多个自动释放池或定期清空池。

有关自动释放池和Objective-C内存管理的更多信息，请参阅高级内存管理编程指南。
 
### 暂停和恢复队列
您可以通过暂停队列来临时阻止队列执行块对象。可以使用dispatch_suspend函数暂停调度队列，并使用dispatch_resume函数恢复调度队列。调用dispatch_suspend会增加队列的挂起引用计数，调用dispatch_resume会减少引用计数。当引用计数大于0时，队列仍然挂起。因此，为了恢复处理块，必须平衡所有挂起调用和匹配的恢复调用。

重要提示:挂起和恢复调用是异步的，只在块的执行之间生效。挂起队列不会导致正在执行的块停止。
 
## 使用分派信号量来调节有限资源的使用
如果提交给调度队列的任务访问某个有限资源，则可能需要使用调度信号量来控制同时访问该资源的任务数量。分派信号量的工作方式与常规信号量类似，但有一个例外。当资源可用时，获取分派信号量所需的时间比获取传统系统信号量所需的时间要少。这是因为在这种特殊情况下，Grand Central Dispatch没有向下调用内核。它向下调用内核的唯一时间是当资源不可用时，系统需要暂停线程，直到发出信号量。
 
使用分派信号量的语义如下:
* 在创建信号量时(使用dispatch_semaphore_create函数)，可以指定一个正整数，表示可用资源的数量。
* 在每个任务中，调用dispatch_semaphore_wait来等待信号量。
* 当等待调用返回时，获取资源并完成工作。
* 当您使用完资源后，释放它，并通过调用dispatch_semaphore_signal函数对信号量发出信号。
 
作为这些步骤如何工作的示例，请考虑在系统上使用文件描述符。每个应用程序使用的文件描述符数量有限。如果您有一个处理大量文件的任务，您不希望一次打开太多文件，以至于耗尽文件描述符。相反，您可以使用信号量来限制文件处理代码在同一时间使用的文件描述符的数量。你可以在任务中加入的基本代码如下:
```
// Create the semaphore, specifying the initial pool size
dispatch_semaphore_t fd_sema);
 
// Wait for a free file descriptor
dispatch_semaphore_wait(fd_sema, DISPATCH_TIME_FOREVER);
fd);
 
// Release the file descriptor when done
close(fd);
dispatch_semaphore_signal(fd_sema);
```
在创建信号量时，可以指定可用资源的数量。这个值成为信号量的初始计数变量。每次在信号量上等待时，dispatch_semaphore_wait函数都会将计数变量减去1。如果结果值为负，该函数告诉内核阻塞线程。在另一端，dispatch_semaphore_signal函数将count变量加1，表示资源已被释放。如果有阻塞的任务等待资源，那么其中一个任务随后将被解除阻塞并允许执行其工作。
 
## 等待队列任务组
分派组是一种阻塞线程直到一个或多个任务完成执行的方法。您可以在所有指定的任务完成之前无法取得进展的地方使用此行为。例如，在分派几个任务来计算一些数据之后，您可以使用一个组来等待这些任务，然后在它们完成时处理结果。使用分派组的另一种方法是作为线程连接的替代方案。您可以将相应的任务添加到分派组中，然后等待整个分派组，而不是启动几个子线程，然后加入每个子线程。

清单3-6显示了设置一个组、向其分配任务和等待结果的基本过程。不是使用dispatch_async函数将任务分派到队列，而是使用dispatch_group_async函数。这个函数将任务与组关联起来，并将其排队等待执行。要等待一组任务完成，然后使用dispatch_group_wait函数，传入适当的组。
 
```
dispatch_queue_t queue);
dispatch_group_t group);
 
// Add a task to the group
dispatch_group_async(group, queue, ^{
   // Some asynchronous work
});
 
// Do some other work while the tasks execute.
 
// When you cannot make any more forward progress,
// wait on the group to block the current thread.
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
 
// Release the group when it is no longer needed.
dispatch_release(group);

```

## 分派队列和线程安全
在分派队列上下文中讨论线程安全似乎有些奇怪，但线程安全仍然是一个相关的主题。当你在你的应用程序中实现并发时，有几件事你应该知道:

* 分派队列本身是线程安全的。换句话说，您可以从系统上的任何线程向调度队列提交任务，而无需首先对队列进行锁或同步访问。
* 不要从传递给函数调用的同一队列上执行的任务调用dispatch_sync函数。这样做将导致队列死锁。如果需要调度到当前队列，请使用dispatch_async函数异步执行此操作。
* 避免从提交到调度队列的任务中获取锁。虽然使用来自任务的锁是安全的，但当您获得锁时，如果该锁不可用，则可能会完全阻塞串行队列。类似地，对于并发队列，等待一个锁可能会阻止其他任务的执行。如果需要同步部分代码，请使用串行分派队列而不是锁。
* 虽然您可以获得有关运行任务的底层线程的信息，但最好避免这样做。有关分派队列与线程的兼容性的更多信息，请参见与POSIX线程的兼容性。
有关如何更改现有线程代码以使用分派队列的其他技巧，请参见从线程迁移。
 
