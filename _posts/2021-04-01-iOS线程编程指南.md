---
layout: post
title: 多线程
subtitle: 多线程编程指南
categories: iOS
tags: [线程]
---
# 线程编程指南
线程是使在单个应用程序中并发执行多个代码路径成为可能的几种技术之一。**但强烈建议使用其它的并发技术。比如NSOperation和GCD,它们简化了实现并发技术执行路径所需的工作量，并提供了比传统线程更好的性能**

## 线程的概念及其在程序设计中的作用
计算机的最大性能在很大程度上受到位于计算机核心的单个微处理器的速度的限制，当单个处理器的速度开始达到其实际极限，芯片制造商转向多核设计，使计算机有机会同时执行多项任务。尽管操作系统可以利用这些核心来执行与系统相关的任务，但自己的应用程序也可以通过线程来利用它们。这就是线程编程。

### 什么是线程
什么是线程?
线程是在应用程序中实现多条执行路径的一种相对轻量级的方法。在系统级，程序是并排运行的，系统根据每个程序的需要和其他程序的需要分配执行时间。然而，在每个程序内部都存在一个或多个执行线程，这些线程可以用来同时或几乎同时地执行不同的任务。系统本身实际上管理这些执行线程，调度它们在可用的内核上运行，并在需要时预先中断它们以允许其他线程运行。

从技术角度来看，线程是管理代码执行所需的内核级和应用程序级数据结构的组合。内核级结构协调事件到线程的调度，以及线程在一个可用内核上的抢占式调度。应用程序级结构包括用于存储函数调用的调用堆栈，以及应用程序管理和操作线程属性和状态所需的结构。

在非并发应用程序中，只有一个执行线程。该线程以应用程序的主例程开始和结束，并逐个分支到实现应用程序整体行为的不同方法或函数。相比之下，支持并发的应用程序从一个线程开始，然后根据需要添加更多线程来创建额外的执行路径。每个新路径都有自己的自定义启动例程，该例程独立于应用程序主例程中的代码运行。在应用程序中使用多线程提供了两个非常重要的潜在优势:

多线程可以提高应用程序的响应能力。
多线程可以提高应用程序在多核系统上的实时性能。
如果您的应用程序只有一个线程，那么这个线程必须完成所有工作。它必须响应事件，更新应用程序的窗口，并执行实现应用程序行为所需的所有计算。只有一个线程的问题是，它一次只能做一件事。那么当你的一个计算需要很长时间才能完成时会发生什么呢?当代码忙于计算所需的值时，应用程序将停止响应用户事件和更新窗口。如果这种行为持续足够长时间，用户可能会认为应用程序挂起并试图强制退出。但是，如果将自定义计算转移到单独的线程上，应用程序的主线程就可以更及时地响应用户交互。

随着多核计算机的普及，线程提供了一种在某些类型的应用程序中提高性能的方法。执行不同任务的线程可以在不同的处理器内核上同时执行不同的任务，这使得应用程序可以在给定的时间内增加它所做的工作量。

当然，线程并不是解决应用程序性能问题的灵丹妙药。线程带来的好处伴随着潜在的问题。在应用程序中使用多条执行路径会给代码增加相当大的复杂性。每个线程必须与其他线程协调其操作，以防止破坏应用程序的状态信息。因为单个应用程序中的线程共享相同的内存空间，所以它们可以访问所有相同的数据结构。如果两个线程试图同时操作相同的数据结构，一个线程可能会以破坏结果数据结构的方式覆盖另一个线程的更改。即使采取了适当的保护措施，您仍然必须注意编译器优化，以免在代码中引入微妙的(不是那么微妙的)错误。

#### 一些基本线程的概念
* 线程指代码的单独执行路径
* 进程指一个运行中的可执行文件
* 任务指需要执行的工作的抽象概念

### 线程的替代方案
* 自己创建线程的一个问题是，它们会给代码增加不确定性。线程是在应用程序中支持并发性的一种相对低级且复杂的方式。如果您没有完全理解设计选择的含义，那么您很容易遇到同步或计时问题，其严重程度可以从细微的行为变化到应用程序崩溃和用户数据损坏。
* 另一个需要考虑的因素是您是否需要线程或并发性。线程解决了如何在同一个进程中并发执行多个代码路径的具体问题。但是，在某些情况下，您正在做的工作量并不能保证并发性。线程给进程带来了大量的开销，包括内存消耗和CPU时间。您可能会发现这个开销对于预期的任务来说太大了，或者其他选项更容易实现。

![IMAGE](/assets/images/resources/59E7E7F068D6E08F14B736EE7F624436.jpg)

### 线程支持
如果你有使用线程的现有代码，OS X和iOS提供了几种在应用程序中创建线程的技术。此外，这两个系统还支持管理和同步需要在这些线程上完成的工作。以下部分描述了在OS X和iOS中使用线程时需要了解的一些关键技术。
### 线程库
尽管线程的底层实现机制是Mach线程，但您很少(如果有的话)在Mach级别上使用线程。相反，您通常使用更方便的POSIX API或其衍生物之一。Mach实现确实提供了所有线程的基本特性，包括抢占式执行模型和调度线程的能力，使它们彼此独立。
![IMAGE](/assets/images/resources/A554AD16161C2274610051CE5FABF167.jpg)
在应用程序级别，所有线程的行为本质上与其他平台上相同。启动线程后，线程以三种主要状态之一运行:正在运行、准备就绪或阻塞。如果一个线程当前没有运行，那么它要么被阻塞并等待输入，要么它已经准备好运行但还没有计划运行。线程继续在这些状态之间来回移动，直到最终退出并移动到终止状态。
创建新线程时，必须为该线程指定一个入口点函数(对于Cocoa线程，则为入口点方法)。这个入口点函数构成了您想要在线程上运行的代码。当函数返回时，或者显式地终止线程时，线程将永久停止并被系统回收。因为在内存和时间方面，线程的创建成本相对较高，因此建议入口点函数执行大量的工作，或者设置一个运行循环以允许执行重复的工作。

### Run Loops
运行循环是一种用于管理线程上异步到达的事件的基础设施。运行循环通过监视线程的一个或多个事件源来工作。当事件到达时，系统唤醒线程并将事件分派给运行循环，然后运行循环将它们分派给您指定的处理程序。如果没有事件，并且没有准备好处理，则运行循环将线程置于睡眠状态。

您不需要对创建的任何线程使用运行循环，但这样做可以为用户提供更好的体验。运行循环使得创建使用最少资源的长寿命线程成为可能。因为运行循环在无事可做时将其线程置于睡眠状态，因此它消除了轮询的需要，轮询浪费了CPU周期，并防止处理器本身进入睡眠状态，从而节省了电源。
要配置运行循环，您所要做的就是启动线程、获取运行循环对象的引用、安装事件处理程序并告诉运行循环运行。OSX提供的基础设施会自动为你处理主线程运行循环的配置。但是，如果您计划创建长期的次要线程，则必须自己为这些线程配置运行循环。

### 同步工具
线程编程的危险之一是多个线程之间的资源争用。如果多个线程试图同时使用或修改同一资源，就会出现问题。缓解该问题的一种方法是完全消除共享资源，并确保每个线程都有自己的不同资源集，可以在其上进行操作。但是，如果不能维护完全独立的资源，则可能必须使用锁、条件、原子操作和其他技术来同步对资源的访问。

锁为一次只能由一个线程执行的代码提供了一种强力保护。最常见的锁类型是互斥锁，也称为互斥锁。当一个线程试图获取当前由另一个线程持有的互斥锁时，它会阻塞，直到锁被另一个线程释放。有几个系统框架提供了对互斥锁的支持，尽管它们都基于相同的底层技术。此外，Cocoa还提供了互斥锁的几种变体，以支持不同类型的行为，比如递归。有关可用锁类型的详细信息，请参见锁。

除了锁之外，系统还提供了对条件的支持，以确保应用程序中任务的正确顺序。条件充当守门人的角色，阻塞给定的线程，直到它所代表的条件变为真。当发生这种情况时，条件释放线程并允许它继续。POSIX层和Foundation框架都为条件提供了直接支持。(如果您使用操作对象，您可以配置操作对象之间的依赖关系，以对任务的执行进行排序，这与条件提供的行为非常相似。)

尽管锁和条件在并发设计中非常常见，但原子操作是保护和同步数据访问的另一种方式。在可以对标量数据类型执行数学或逻辑操作的情况下，原子操作提供了一种轻量级的锁替代方案。原子操作使用特殊的硬件指令来确保在其他线程有机会访问变量之前完成对变量的修改。

### 线程通信
尽管一个好的设计可以最小化所需的通信量，但在某些时候，线程之间的通信是必要的。(线程的工作是为您的应用程序工作，但如果该工作的结果从未被使用，它有什么好处?)线程可能需要处理新的作业请求或向应用程序的主线程报告它们的进度。在这些情况下，您需要一种从一个线程到另一个线程获取信息的方法。幸运的是，线程共享相同的进程空间这一事实意味着您有很多通信选项。
线程之间有许多通信方法，每种方法都有其优缺点。配置线程本地存储列出了在OS x中可以使用的最常见的通信机制(除了消息队列和Cocoa分布式对象之外，这些技术在iOS中也可用)。此表中的技术是按复杂性增加的顺序列出的。
![IMAGE](/assets/images/resources/D992DABDE88CF444BE32CF29E869A15E.jpg)

### 设计技巧
#### 避免直接创建线程
手动编写线程创建代码非常繁琐，而且可能容易出错，您应该尽可能避免使用这种方法。OS X和iOS通过其他api提供了对并发的隐式支持。与其自己创建线程，不如考虑使用异步api、GCD或操作对象来完成工作。这些技术在幕后为您执行与线程相关的工作，并保证正确执行。此外，GCD和操作对象等技术设计用于管理线程，比您自己的代码更有效，它们可以根据当前系统负载调整活动线程的数量。有关GCD和操作对象的更多信息，请参见并发编程指南。

#### 让线程保持忙碌
如果决定手动创建和管理线程，请记住线程会消耗宝贵的系统资源。您应该尽最大努力确保您分配给线程的任何任务都是合理的长生命周期和高效的。与此同时，您不应该害怕终止那些大部分时间都处于空闲状态的线程。线程使用大量的内存，其中一些是连接的，因此释放空闲线程不仅有助于减少应用程序的内存占用，还可以释放更多的物理内存供其他系统进程使用。

重要提示:在开始终止空闲线程之前，应该始终记录一组应用程序当前性能的基线测量值。在尝试更改之后，采取额外的度量来验证更改实际上提高了性能，而不是损害了性能。
 
#### 避免共享数据结构
避免线程相关资源冲突的最简单的方法是为程序中的每个线程提供其所需数据的副本。当线程之间的通信和资源争用最小化时，并行代码的工作效果最好。

创建多线程应用程序是困难的。即使您非常小心，并在代码中所有正确的节点锁定共享数据结构，您的代码仍然可能在语义上不安全。例如，如果您的代码期望以特定顺序修改共享数据结构，则可能会遇到问题。将代码更改为基于事务的模型以进行补偿，随后可能会抵消多线程的性能优势。首先消除资源争用通常会产生更简单的设计和出色的性能。
 
#### 线程和用户界面
如果应用程序具有图形用户界面，建议从应用程序主线程接收与用户相关的事件并初始化界面更新。这种方法有助于避免与处理用户事件和绘制窗口内容相关的同步问题。一些框架(如Cocoa)通常需要这种行为，但即使对于那些不需要这种行为的框架，将这种行为保留在主线线程上也具有简化管理用户界面的逻辑的优点。

有一些值得注意的例外，从其他线程执行图形化操作是有利的。例如，可以使用辅助线程创建和处理映像，并执行其他与映像相关的计算。为这些操作使用辅助线程可以大大提高性能。如果你不确定某个特定的图形化操作，那就在主线程中进行。

有关Cocoa线程安全的更多信息，请参见线程安全摘要。有关在Cocoa中绘图的更多信息，请参阅Cocoa绘图指南。

#### 注意线程退出时的行为
进程一直运行到所有未分离的线程退出为止。默认情况下，只有应用程序的主线程被创建为非分离线程，但您也可以以这种方式创建其他线程。当用户退出应用程序时，通常认为立即终止所有已分离线程是合适的行为，因为已分离线程所做的工作被认为是可选的。但是，如果应用程序使用后台线程将数据保存到磁盘或执行其他关键工作，则可能希望将这些线程创建为非分离线程，以防止应用程序退出时数据丢失。

创建非分离的线程(也称为可接合的)需要额外的工作。因为大多数高级线程技术默认情况下不创建可接合的线程，所以您可能必须使用POSIX API来创建线程。此外，必须在应用程序的主线程中添加代码，以便在未分离的线程最终退出时与它们连接。有关创建可连接线程的信息，请参见设置线程的分离状态。

如果您正在编写Cocoa应用程序，您还可以使用applicationShouldTerminate: delegate方法将应用程序的终止延迟到稍后的时间或完全取消它。当延迟终止时，您的应用程序需要等待，直到任何关键线程都完成了它们的任务，然后调用replyToApplicationShouldTerminate:方法。有关这些方法的更多信息，请参阅NSApplication类参考。
 
#### 处理异常
异常处理机制依赖于当前调用堆栈在抛出异常时执行任何必要的清理。因为每个线程都有自己的调用堆栈，因此每个线程都负责捕获自己的异常。在辅助线程中捕获异常失败与在主线程中捕获异常失败是一样的:所属进程被终止。不能将未捕获的异常抛出到不同的线程进行处理。

如果需要将当前线程中的异常情况通知另一个线程(例如主线程)，则应该捕获异常并向其他线程发送一条消息，指出发生了什么。根据您的模型和您要做的事情，捕获异常的线程可以继续处理(如果可能的话)，等待指令，或者干脆退出。

注意:在Cocoa中，NSException对象是一个自包含的对象，一旦它被捕获，就可以在线程之间传递。

在某些情况下，可能会自动为您创建异常处理程序。例如，Objective-C中的@synchronized指令包含一个隐式异常处理程序。
 
#### 干净的结束线程
干净利落地终止线程
线程退出的最佳方式是自然地让它到达主入口点例程的末尾。尽管有一些函数可以立即终止线程，但这些函数只能作为最后的手段使用。在线程到达其自然终点之前终止线程，可以防止线程自行清理。如果线程分配了内存、打开了文件或获得了其他类型的资源，那么您的代码可能无法回收这些资源，从而导致内存泄漏或其他潜在的问题。
有关退出线程的正确方法的更多信息，请参见终止线程。

#### 库的线程安全 
虽然应用程序开发人员可以控制应用程序是否使用多线程执行，但库开发人员不能。在开发库时，必须假设调用应用程序是多线程的，或者可以随时切换为多线程。因此，您应该始终对代码的关键部分使用锁。

对于库开发人员来说，仅在应用程序变成多线程时才创建锁是不明智的。如果您需要在某个时刻锁定代码，请在使用库的早期创建锁对象，最好是在某种显式调用中初始化库。虽然也可以使用静态库初始化函数来创建这样的锁，但只有在没有其他方法的情况下才尝试这样做。执行初始化函数会增加加载库所需的时间，并可能对性能产生不利影响。

注意:始终记住在库中平衡锁和锁的调用。您还应该记住锁定库数据结构，而不是依赖调用代码来提供线程安全的环境。

如果你正在开发一个Cocoa库，你可以注册为NSWillBecomeMultiThreadedNotification的观察者，如果你想在应用程序变成多线程时得到通知。但是，您不应该依赖于接收此通知，因为它可能在调用库代码之前就被分派了。
 

## 线程管理及如何使用
### 线程管理
线程管理
OS X或iOS中的每个进程(应用程序)都由一个或多个线程组成，每个线程代表应用程序代码的单个执行路径。每个应用程序都从一个线程开始，该线程运行应用程序的主函数。应用程序可以产生额外的线程，每个线程执行特定函数的代码。

当应用程序生成一个新线程时，该线程就成为应用程序进程空间中的一个独立实体。每个线程都有自己的执行堆栈，并由内核分别调度运行时。线程可以与其他线程和其他进程通信，执行I/O操作，以及执行您可能需要它做的任何其他事情。但是，由于它们位于相同的进程空间中，因此单个应用程序中的所有线程共享相同的虚拟内存空间，并具有与进程本身相同的访问权限。

本章概述了OS X和iOS中可用的线程技术，并举例说明如何在应用程序中使用这些技术。

注意:要了解Mac OS线程架构的历史，以及关于线程的其他背景信息，请参阅技术说明TN2028，“线程架构”。

### 线程的成本
在内存使用和性能方面，线程对程序(和系统)有实际的成本。每个线程都需要在内核内存空间和程序的内存空间中分配内存。管理线程和协调线程调度所需的核心结构使用有线内存存储在内核中。线程的堆栈空间和每个线程的数据存储在程序的内存空间中。这些结构中的大多数都是在您第一次创建线程时创建和初始化的——由于需要与内核进行交互，这个过程可能相对昂贵。

表2-1量化了在应用程序中创建新用户级线程相关的大致成本。其中一些成本是可配置的，例如为次要线程分配的堆栈空间量。创建一个线程的时间成本是一个粗略的近似值，应该仅用于彼此之间的相对比较。线程创建时间可能会根据处理器负载、计算机速度以及可用系统和程序内存的大小而有很大差异。
 ![IMAGE](/assets/images/resources/8CA81C0DA9512B7360F20BF1D6BC0DCD.jpg)
编写线程代码时要考虑的另一个成本是生产成本。设计线程应用程序有时需要对应用程序数据结构的组织方式进行根本性的更改。为了避免使用同步，进行这些更改可能是必要的，同步本身可能会对设计糟糕的应用程序造成巨大的性能损失。设计这些数据结构，并调试线程代码中的问题，会增加开发线程应用程序所需的时间。然而，如果线程花费太多时间等待锁或什么都不做，避免这些成本可能会在运行时产生更大的问题。
 
### 创建一个线程
创建低级线程相对简单。在所有情况下，必须有一个函数或方法作为线程的主要入口点，并且必须使用一个可用的线程例程来启动线程。下面几节展示了更常用的线程技术的基本创建过程。使用这些技术创建的线程继承了一组默认属性，由您使用的技术决定。有关如何配置线程的信息，请参见配置线程属性。

#### 使用NSThread
有两种方法可以使用NSThread类来创建线程
* 使用`detachNewThreadSelector:toTarget:withObject: `类方法来生成新线程
* 创建一个新的**NSThread**实例对象并且调用它的**start**方法（仅支持iOS和OS X v10.5及以上版本）

这两种技术都在应用程序中创建独立线程。分离的线程意味着当线程退出时，系统会自动回收线程的资源。这也意味着您的代码以后不必显式地与线程连接。
因为所有版本的OS X都支持detachNewThreadSelector:toTarget:withObject:方法，所以它经常出现在现有的使用线程的Cocoa应用程序中。要分离一个新线程，只需提供希望用作线程入口点的方法名称(作为选择器指定)、定义该方法的对象，以及在启动时希望传递给线程的任何数据。下面的示例展示了此方法的基本调用，该方法使用当前对象的自定义方法生成线程。
如果你有一个NSThread对象，它的线程当前正在运行，你可以向该线程发送消息的一种方法是使用应用程序中几乎所有对象的performSelector:onThread:withObject:waitUntilDone:方法。支持在线程(主线程以外)上执行选择器是在OS X v10.5中引入的，这是一种在线程之间进行通信的方便方式。(iOS系统也支持这一功能。)使用此技术发送的消息由另一个线程直接执行，作为其正常运行循环处理的一部分。(当然，这意味着目标线程必须在它的run循环中运行;参见Run Loops。)当以这种方式通信时，您可能仍然需要某种形式的同步，但这比在线程之间设置通信端口简单。

注意:虽然适用于线程间的偶尔通信，但对于时间紧迫或频繁的线程间通信，你不应该使用performSelector:onThread:withObject:waitUntilDone:方法。

#### 使用POSIX线程
OS X和iOS提供了使用POSIX线程API创建线程的基于c语言的支持。这项技术实际上可以用于任何类型的应用程序(包括Cocoa和Cocoa Touch应用程序)，如果您正在为多个平台编写软件，可能会更方便。用于创建线程的POSIX例程称为pthread_create。

清单2-1展示了使用POSIX调用创建线程的两个自定义函数。LaunchThread函数创建一个新线程，其主例程在PosixThreadMainRoutine函数中实现。因为POSIX默认将线程创建为可连接的，所以本示例更改线程的属性以创建分离的线程。将线程标记为已分离线程使系统有机会在线程退出时立即回收该线程的资源。
![IMAGE](/assets/images/resources/8DD16C0239B4BB598355EE4DE0FEFC6E.jpg)
如果将上面清单中的代码添加到一个源文件中，并调用LaunchThread函数，它将在应用程序中创建一个新的独立线程。当然，使用这段代码创建的新线程不会做任何有用的事情。线程将启动并几乎立即退出。为了让事情变得更有趣，您需要向PosixThreadMainRoutine函数添加代码来完成一些实际的工作。为了确保线程知道要做什么工作，可以在创建时将指向某些数据的指针传递给线程。将此指针作为pthread_create函数的最后一个参数传递。

要将信息从新创建的线程传递回应用程序的主线程，需要在目标线程之间建立通信路径。对于基于c的应用程序，线程之间有几种通信方式，包括使用端口、条件或共享内存。对于长期存在的线程，几乎总是应该设置某种线程间通信机制，使应用程序的主线程能够检查线程的状态，或者在应用程序退出时彻底关闭线程。

有关POSIX线程函数的更多信息，请参阅pthread手册页。
 
#### 使用NSObject生成线程
在iOS和OS X v10.5及更高版本中，所有对象都能够生成一个新线程并使用它来执行它们的方法之一。performSelectorInBackground:withObject:方法创建一个新的分离线程，并使用指定的方法作为新线程的入口点。例如，如果你有一些对象(由变量myObj表示)，并且该对象有一个名为doSomething的方法，你想在后台线程中运行，你可以使用以下代码来完成:
`[myObj performSelectorInBackground:@selector(doSomething) withObject:nil];`
调用这个方法的效果和你用当前对象、选择器和参数对象作为参数调用NSThread的detachNewThreadSelector:toTarget:withObject:方法是一样的。使用默认配置立即生成新线程并开始运行。在选择器内部，必须像配置任何线程一样配置线程。例如，您需要设置一个自动释放池(如果您不使用垃圾收集)，如果您计划使用线程的运行循环，则需要配置它。有关如何配置新线程的信息，请参见配置线程属性。

#### 在Cocoa应用中使用POSIX线程
尽管NSThread类是在Cocoa应用程序中创建线程的主要接口，如果这样做对你更方便的话，你可以自由地使用POSIX线程。例如，如果已经有使用POSIX线程的代码，并且不希望重写它，则可以使用POSIX线程。如果您确实计划在Cocoa应用程序中使用POSIX线程，那么您仍然应该注意Cocoa和线程之间的交互，并遵守以下部分中的指导原则。

保护Cocoa框架
对于多线程应用程序，Cocoa框架使用锁和其他形式的内部同步来确保它们的行为正确。然而，为了防止这些锁在单线程情况下降低性能，Cocoa直到应用程序使用NSThread类生成第一个新线程时才创建它们。如果只使用POSIX线程例程生成线程，Cocoa不会收到它需要知道应用程序现在是多线程的通知。当这种情况发生时，涉及Cocoa框架的操作可能会使应用程序不稳定或崩溃。

要让Cocoa知道您打算使用多个线程，您所要做的就是使用NSThread类生成一个线程，并让该线程立即退出。线程入口点不需要做任何事情。仅仅使用NSThread生成一个线程就足以确保Cocoa框架所需的锁被放置到位。

如果你不确定Cocoa是否认为你的应用程序是多线程的，你可以使用NSThread的ismultithreading方法来检查。

混合POSIX和Cocoa锁
在同一个应用程序中混合使用POSIX和Cocoa锁是安全的。可可锁和条件对象本质上只是POSIX互斥对象和条件的包装。但是，对于给定的锁，必须始终使用相同的接口来创建和操作该锁。换句话说，您不能使用Cocoa NSLock对象来操作使用pthread_mutex_init函数创建的互斥量，反之亦然。
 
### 配置线程属性
在创建线程之后(有时在创建线程之前)，您可能希望配置线程环境的不同部分。以下部分描述了您可以进行的一些更改以及何时进行更改。

#### 配置线程的堆栈大小
对于您创建的每个新线程，系统将在进程空间中分配特定数量的内存量，作为该线程的堆栈。堆栈管理堆栈框架，也是声明线程的任何局部变量的地方。为线程分配的内存量列在线程成本中。
![IMAGE](/assets/images/resources/AF9B7345F6598AAD674A8618C9DC6C64.jpg)

#### 配置线程本地存储
每个线程维护一个键值对字典，可以从线程中的任何地方访问这些字典。您可以使用这个字典来存储希望在线程执行过程中持久化的信息。例如，您可以使用它来存储您希望在线程的运行循环的多次迭代中持久化的状态信息。

Cocoa和POSIX以不同的方式存储线程字典，因此不能混合和匹配对这两种技术的调用。但是，只要在线程代码中坚持使用一种技术，最终结果应该是类似的。在Cocoa中，你可以使用NSThread对象的threadDictionary方法来检索一个NSMutableDictionary对象，你可以向它添加线程所需的任何键。在POSIX中，您使用pthread_setspecific和pthread_getspecific函数来设置和获取线程的键和值。

如果要更改给定线程的堆栈大小，必须在创建线程之前执行此操作。所有的线程技术都提供了一些设置堆栈大小的方法，尽管使用NSThread设置堆栈大小仅在iOS和OS X v10.5及更高版本中可用。各技术选项如表2-2所示。
 
#### 设置线程的分离状态
大多数高级线程技术默认创建分离线程。在大多数情况下，分离线程是首选的，因为它们允许系统在线程完成后立即释放线程的数据结构。分离的线程也不需要与程序进行显式交互。从线程中检索结果的方法由您自行决定。相比之下，系统不会回收可连接线程的资源，直到另一个线程显式地与该线程连接，这个进程可能会阻塞执行连接的线程。

您可以将可接合线程看作类似于子线程。尽管它们仍然作为独立的线程运行，但在系统回收其资源之前，可接合线程必须由另一个线程连接。可接合线程还提供了一种显式的方式来将数据从现有线程传递到另一个线程。在退出之前，可接合线程可以将数据指针或其他返回值传递给pthread_exit函数。然后，另一个线程可以通过调用pthread_join函数来声明该数据。

重要提示:在应用程序退出时，分离的线程可以立即终止，但可接合的线程不能。每个可连接的线程必须在进程允许退出之前被连接。因此，在线程正在执行不应中断的关键工作(如将数据保存到磁盘)的情况下，可接合线程可能更可取。

如果您确实希望创建可接合的线程，那么惟一的方法就是使用POSIX线程。POSIX默认将线程创建为可接合的。要将线程标记为分离的或可接合的，请在创建线程之前使用pthread_attr_setdetachstate函数修改线程属性。线程开始后，可以通过调用pthread_detach函数将可接合线程更改为分离线程。有关这些POSIX线程函数的更多信息，请参阅pthread手册页。有关如何连接线程的信息，请参阅pthread_join手册页。

#### 设置线程优先级
您创建的任何新线程都有一个与之关联的默认优先级。内核的调度算法在决定运行哪个线程时考虑线程优先级，高优先级的线程比低优先级的线程更有可能运行。高优先级并不能保证线程的特定执行时间，只是与低优先级线程相比，它更有可能被调度器选择。

重要提示:将线程的优先级保留为默认值通常是个好主意。提高某些线程的优先级还会增加低优先级线程饥饿的可能性。如果您的应用程序包含必须相互交互的高优先级和低优先级线程，低优先级线程的饥饿可能会阻塞其他线程并造成性能瓶颈。

如果您确实想修改线程优先级，Cocoa和POSIX都提供了一种方法。对于Cocoa线程，你可以使用NSThread的setThreadPriority: class方法来设置当前运行线程的优先级。对于POSIX线程，使用pthread_setschedparam函数。有关更多信息，请参阅NSThread类参考或pthread_setschedparam手册页。
 
### 编写线程入口例程
在大多数情况下，线程入口点例程的结构在OS X和在其他平台上是一样的。初始化数据结构，执行一些工作或可选地设置一个运行循环，并在线程代码完成时进行清理。根据您的设计，在编写输入例程时可能需要采取一些额外的步骤。

#### 创建一个自动释放池
在Objective-C框架中链接的应用程序通常必须在它们的每个线程中至少创建一个自动释放池。如果应用程序使用托管模型(其中应用程序处理对象的保留和释放)，自动释放池将捕获从该线程自动释放的任何对象。

如果应用程序使用垃圾收集而不是托管内存模型，则不严格需要创建自动释放池。在垃圾收集的应用程序中存在自动释放池是无害的，并且在大多数情况下会被忽略。在代码模块必须同时支持垃圾收集和托管内存模型的情况下，允许使用这种方法。在这种情况下，必须出现自动释放池以支持托管内存模型代码，如果应用程序运行时启用了垃圾收集，则自动释放池将被忽略。

如果您的应用程序使用托管内存模型，那么创建自动释放池应该是您在线程输入例程中要做的第一件事。类似地，销毁这个自动释放池应该是在线程中做的最后一件事。这个池确保自动释放的对象被捕获，尽管它直到线程本身退出才释放它们。清单2-2显示了使用自动释放池的基本线程入口例程的结构。
![IMAGE](/assets/images/resources/2A773C06D362467DD50B76CACC1C8D4B.jpg)
因为顶级的自动释放池直到线程退出才释放它的对象，所以长期存在的线程应该创建额外的自动释放池来更频繁地释放对象。例如，使用运行循环的线程可以每次通过该运行循环创建并释放一个自动释放池。更频繁地释放对象可以防止应用程序的内存占用变得过大，从而导致性能问题。与任何与性能相关的行为一样，您应该衡量代码的实际性能，并适当地调优自动发布池的使用。

有关内存管理和自动释放池的更多信息，请参阅高级内存管理编程指南。
 
#### 设置异常处理程序
如果应用程序捕获并处理异常，那么线程代码应该准备捕获可能发生的任何异常。尽管最好在可能发生异常的地方处理异常，但如果在线程中捕捉不到抛出的异常，则会导致应用程序退出。在线程入口例程中安装最后的try/catch可以捕获任何未知异常并提供适当的响应。

在Xcode中构建项目时，可以使用c++或Objective-C异常处理风格。有关在Objective-C中设置如何引发和捕获异常的信息，请参见异常编程主题。

#### 设置运行循环
当编写希望在单独的线程上运行的代码时，有两个选项。第一种选择是将线程的代码编写为一个长任务，在很少或没有中断的情况下执行，并在线程完成时退出。第二种方法是将线程放入循环中，并在请求到达时动态处理请求。第一个选项不需要对代码进行特殊设置;你只要开始做你想做的工作。然而，第二个选项涉及设置线程的运行循环。

OS X和iOS为在每个线程中实现运行循环提供了内置支持。应用程序框架自动启动应用程序主线程的运行循环。如果创建任何辅助线程，则必须配置运行循环并手动启动它。

有关使用和配置运行循环的信息，请参见运行循环。
 
### 终止线程
退出线程的推荐方法是让线程正常退出其入口点例程。尽管Cocoa、POSIX和Multiprocessing Services提供了直接杀死线程的例程，但强烈不鼓励使用这种例程。杀死一个线程可以防止该线程清理自己。线程分配的内存可能会泄漏，线程当前使用的任何其他资源可能不会被正确清理，从而在以后产生潜在的问题。

如果您预计需要在操作中终止线程，那么应该从一开始就设计线程以响应取消或退出消息。对于长时间运行的操作，这可能意味着定期停止工作并检查这样的消息是否到达。如果确实有消息请求线程退出，那么线程将有机会执行任何所需的清理并优雅地退出;否则，它可以简单地回去工作并处理下一个数据块。

响应取消消息的一种方法是使用运行循环输入源来接收此类消息。清单2-3显示了这段代码在线程的主入口例程中的结构。(该示例只显示了主循环部分，不包括设置自动释放池或配置实际工作的步骤。)该示例在运行循环上安装了一个自定义输入源，该输入源可以从另一个线程进行消息传递;有关设置输入源的信息，请参见配置运行循环源。在执行了总工作量的一部分之后，线程简短地运行run循环，以查看是否有消息到达输入源。如果不是，则运行循环立即退出，并继续执行下一个工作块。因为处理程序不能直接访问exitNow局部变量，所以退出条件是通过线程字典中的键值对进行通信的。

![IMAGE](/assets/images/resources/A756A791504A788232E2AF21D2AB3D35.jpg)


## 在其它线程中如何管理事件处理循环(runloop)
详见单独的runloop介绍

## 同步问题和防止多线程破坏数据或是程序崩溃的工具
### 同步
应用程序中存在多个线程会引发从多个执行线程安全访问资源的潜在问题。修改同一资源的两个线程可能会以意想不到的方式相互干扰。例如，一个线程可能会覆盖另一个线程的更改，或者将应用程序置于未知的、潜在的无效状态。如果幸运的话，损坏的资源可能会导致明显的性能问题或崩溃，这些问题相对容易追踪和修复。但是，如果您很不幸，损坏可能会导致直到很久以后才会显现出来的细微错误，或者这些错误可能需要对您的底层编码假设进行重大检查。

当谈到线程安全时，一个好的设计是你所拥有的最好的保护。避免共享资源和最小化线程之间的交互，可以降低这些线程相互干扰的可能性。然而，完全无干扰的设计并不总是可能的。在线程必须交互的情况下，您需要使用同步工具来确保它们在交互时是安全的。

OS X和iOS提供了大量的同步工具供您使用，从提供互斥访问的工具到在应用程序中正确排序事件的工具。下面几节将描述这些工具，以及如何在代码中使用它们来影响对程序资源的安全访问。

### 同步工具
为了防止不同线程意外地更改数据，可以将应用程序设计为不存在同步问题，也可以使用同步工具。尽管完全避免同步问题是可取的，但这并不总是可能的。以下部分描述了可供您使用的同步工具的基本类别。

#### 原子操作
原子操作是对简单数据类型进行同步的一种简单形式。原子操作的优点是它们不会阻塞竞争线程。对于简单的操作，例如递增计数器变量，这比使用锁可以获得更好的性能。
OS X和iOS包含大量对32位和64位值执行基本数学和逻辑操作的操作。这些操作包括比较-交换、测试-设置和测试-清除操作的原子版本。有关支持的原子操作的列表，请参阅/usr/include/libkern/ osatom .h头文件或参阅原子手册页。

#### 内存屏障和Volatile变量
为了实现最佳性能，编译器通常会重新排序汇编级指令，以使处理器的指令管道尽可能满。作为这种优化的一部分，当编译器认为这样做不会产生错误的数据时，它可能会对访问主存的指令重新排序。不幸的是，编译器并不总是能够检测到所有依赖于内存的操作。如果看似独立的变量实际上相互影响，编译器优化可能会以错误的顺序更新这些变量，从而产生可能不正确的结果。

内存屏障是一种非阻塞同步工具，用于确保内存操作以正确的顺序发生。内存屏障就像围栏一样，迫使处理器完成位于屏障前面的任何加载和存储操作，然后才允许它执行位于屏障之后的加载和存储操作。内存屏障通常用于确保一个线程(但对另一个线程可见)的内存操作总是以预期的顺序发生。在这种情况下，缺乏内存屏障可能会让其他线程看到看似不可能的结果。(例如，请参阅维基百科的内存障碍条目。)要使用内存屏障，只需在代码中的适当位置调用omemorybarrier函数。

Volatile变量对单个变量应用另一种类型的内存限制。编译器通常通过将变量的值加载到寄存器中来优化代码。对于局部变量，这通常不是问题。但是，如果变量在另一个线程中可见，这样的优化可能会阻止其他线程注意到对它的任何更改。对变量应用volatile关键字会迫使编译器在每次使用该变量时从内存中加载该变量。如果一个变量的值可能在任何时候被编译器无法检测到的外部源更改，则可以将其声明为volatile。

因为内存屏障和易失性变量都会减少编译器可以执行的优化次数，所以应该谨慎使用，只在需要确保正确性的地方使用。有关使用内存屏障的信息，请参阅omemorybarrier手册页
 
#### 锁
锁是最常用的同步工具之一。您可以使用锁来保护代码的关键部分，这是一段代码，一次只允许一个线程访问。例如，临界区可能操作特定的数据结构或使用一次最多支持一个客户机的某些资源。通过在此部分周围放置一个锁，可以排除其他线程做出可能影响代码正确性的更改。

表4-1列出了程序员常用的一些锁。OS X和iOS提供了这些锁类型的大部分实现，但不是全部。对于不支持的锁类型，描述列解释了为什么这些锁没有直接在平台上实现。
 ![IMAGE](/assets/images/resources/2A14AF428FC878124413701154D05E78.jpg)
 
#### 条件
条件是另一种类型的信号量，它允许线程在某个条件为真时相互发送信号。条件通常用于指示资源的可用性或确保任务按特定顺序执行。当线程测试一个条件时，它将阻塞，除非该条件已经为真。它一直处于阻塞状态，直到其他线程显式地更改并发出该条件的信号。条件锁和互斥锁的区别在于，可以允许多个线程同时访问条件锁。这个条件更像是一个看门人，根据某些指定的标准让不同的线程通过这个门。

使用条件的一种方法是管理挂起事件池。当队列中有事件时，事件队列将使用一个条件变量向等待线程发出信号。如果一个事件到达，队列将适当地发出条件信号。如果一个线程已经在等待，它将被唤醒，然后它将从队列中提取事件并处理它。如果两个事件几乎同时进入队列，队列将发出两次条件信号以唤醒两个线程。

该系统提供了几种不同技术条件的支持。然而，条件的正确实现需要仔细编码，因此在您自己的代码中使用它们之前，应该先查看Using conditions中的示例。

#### 执行选择器例程
Cocoa应用程序有一种以同步方式向单个线程传递消息的方便方法。NSObject类声明了在应用程序的一个活动线程上执行选择器的方法。这些方法允许线程以异步方式传递消息，并保证这些消息将由目标线程同步执行。例如，您可以使用执行选择器消息将分布式计算的结果传递到应用程序的主线程或指定的协调线程。执行选择器的每个请求都在目标线程的运行循环中排队，然后按照接收的顺序依次处理请求。

有关执行选择器例程的摘要和关于如何使用它们的更多信息，请参阅Cocoa执行选择器源代码。
 
### 同步的成本和性能
同步有助于确保代码的正确性，但这是以牺牲性能为代价的。同步工具的使用会带来延迟，即使在无争议的情况下也是如此。锁和原子操作通常涉及使用内存屏障和内核级同步，以确保代码得到适当的保护。如果存在对锁的争用，线程可能会阻塞并经历更大的延迟。

表4-2列出了在无争用情况下与互斥对象和原子操作相关的一些大致代价。这些测量值代表了数千个样本的平均采集时间。与线程创建时间一样，互斥量获取时间(即使是在无竞争的情况下)也会根据处理器负载、计算机速度以及可用系统和程序内存的数量而有很大差异。
 ![IMAGE](/assets/images/resources/A8AE6908C6B8DDB4ADA2DCA1C8F1E1CB.jpg)
在设计并发任务时，正确性始终是最重要的因素，但也应该考虑性能因素。在多个线程下正确执行的代码，但比在单个线程上运行的相同代码慢，这很难说是一种改进。

如果您正在改造现有的单线程应用程序，那么您应该始终对关键任务的性能进行一组基线测量。在添加额外的线程之后，您应该对这些相同的任务进行新的测量，并比较多线程情况和单线程情况的性能。如果在优化代码后，线程并不能提高性能，那么您可能需要重新考虑特定的实现或线程的使用。

有关性能和收集度量的工具的信息，请参见性能概述。有关锁和原子操作成本的具体信息，请参见线程成本。
 
### 线程安全和信号
当谈到线程应用程序时，没有什么比处理信号的问题更令人恐惧或困惑了。信号是一种低级的BSD机制，可用于向进程传递信息或以某种方式对其进行操作。有些程序使用信号来检测某些事件，例如子进程的死亡。系统使用信号来终止失控进程并传递其他类型的信息。

信号的问题不在于它们做什么，而在于当应用程序有多个线程时它们的行为。在单线程应用程序中，所有信号处理程序都运行在主线程上。在多线程应用程序中，没有绑定到特定硬件错误(例如非法指令)的信号被传递给当时恰好正在运行的线程。如果多个线程同时运行，信号将被传递到系统碰巧选择的任何一个线程。换句话说，信号可以传递到应用程序的任何线程。

在应用程序中实现信号处理程序的第一条规则是避免假设哪个线程在处理信号。如果一个特定的线程想要处理一个给定的信号，那么您需要想出某种方法在信号到达时通知该线程。您不能假设从该线程安装信号处理程序将导致信号被传递到同一线程。

有关信号和安装信号处理程序的更多信息，请参阅signal和sigaction手册页。
 
### 线程安全设计的技巧
同步工具是使代码线程安全的一种有用的方法，但它们不是万能的。如果锁和其他类型的同步原语使用过多，实际上会降低应用程序的线程性能，而不是非线程性能。在安全性和性能之间找到正确的平衡是一门需要经验的艺术。以下部分提供了一些技巧，帮助您为应用程序选择适当的同步级别。
 
#### 完全避免同步
对于您从事的任何新项目，甚至对于现有项目，设计代码和数据结构以避免同步需求是可能的最佳解决方案。尽管锁和其他同步工具很有用，但它们确实会影响任何应用程序的性能。如果整体设计导致特定资源之间的高度争用，那么线程的等待时间可能会更长。

实现并发性的最佳方法是减少并发任务之间的交互和相互依赖。如果每个任务操作它自己的私有数据集，它不需要使用锁来保护该数据。即使在两个任务确实共享一个公共数据集的情况下，您也可以考虑划分该数据集或为每个任务提供其自己的副本的方法。当然，复制数据集也有它的成本，所以在做出决定之前，您必须权衡这些成本和同步成本。
 
#### 了解同步的局限性
只有当应用程序中的所有线程一致地使用同步工具时，它们才有效。如果创建互斥来限制对特定资源的访问，则所有线程在尝试操作该资源之前必须获得相同的互斥。如果不这样做，互斥锁提供的保护就失效了，这是一个程序员错误。

#### 主要对代码正确性的威胁
在使用锁和内存屏障时，您应该始终仔细考虑它们在代码中的位置。即使锁看起来放得很好，实际上也会让你产生一种虚假的安全感。下面的一系列示例试图通过指出看似无伤大雅的代码中的缺陷来说明这个问题。基本前提是你有一个可变数组，包含一组不可变对象。假设您想调用数组中第一个对象的方法。你可以使用下面的代码:
 ![IMAGE](/assets/images/resources/AD41E5A0A2FD507A2164997C6FFCD6E2.jpg)
因为数组是可变的，所以数组周围的锁阻止其他线程修改数组，直到您获得所需的对象。因为检索的对象本身是不可变的，所以在调用doSomething方法时不需要锁。

不过，前面的例子有一个问题。如果您释放锁，另一个线程进入并在您有机会执行doSomething方法之前从数组中删除所有对象，会发生什么?在没有垃圾收集的应用程序中，您的代码所持有的对象可能会被释放，留下指向无效内存地址的object。为了解决这个问题，你可能会决定简单地重新排列你现有的代码，并在调用doSomething之后释放锁，如下所示:
 ![IMAGE](/assets/images/resources/2AD1918BF400D1AC6C44D4874EC8C545.jpg)
通过将doSomething调用移动到锁内部，代码可以保证在调用方法时对象仍然有效。不幸的是，如果doSomething方法需要很长时间才能执行，这可能会导致代码长时间持有锁，从而造成性能瓶颈。

代码的问题不在于关键区域定义得不好，而在于没有理解实际的问题。真正的问题是内存管理问题，只有当其他线程存在时才会触发。因为它可以由另一个线程释放，所以更好的解决方案是在释放锁之前保留一个object。此解决方案解决了对象被释放的实际问题，并且不会引入潜在的性能损失。
 ![IMAGE](/assets/images/resources/40B4D3214D00FA44E15B552392AA6175.jpg)
虽然前面的例子在本质上非常简单，但它们确实说明了一个非常重要的问题。当涉及到正确性时，你必须跳出这些明显的问题。内存管理和设计的其他方面也可能受到多线程的影响，因此必须预先考虑这些问题。此外，在安全方面，您应该始终假定编译器会做最糟糕的事情。这种意识和警惕性将帮助您避免潜在的问题，并确保您的代码正确运行。

有关如何使程序线程安全的其他示例，请参见线程安全摘要。

### 小心死锁和活锁
任何时候，一个线程试图同时获得多个锁，就有可能发生死锁。当两个不同的线程持有另一个线程需要的锁，然后试图获得另一个线程持有的锁时，就会发生死锁。结果是每个线程永久阻塞，因为它永远无法获得另一个锁。

活锁类似于死锁，当两个线程竞争同一组资源时就会发生活锁。在活锁情况下，线程放弃第一个锁，试图获得第二个锁。一旦它获得第二个锁，它就会返回并再次尝试获得第一个锁。它锁定是因为它把所有的时间都花在释放一个锁上，并试图获得另一个锁上，而不是做任何实际的工作。

避免死锁和活锁情况的最佳方法是一次只使用一个锁。如果必须一次获得多个锁，则应该确保其他线程不会尝试做类似的事情。
 
### 正确使用易变变量
如果你已经使用互斥来保护一段代码，不要自动认为你需要使用volatile关键字来保护该段代码中的重要变量。互斥包括一个内存屏障，以确保加载和存储操作的正确顺序。将volatile关键字添加到临界区中的变量时，每次访问该值时都会强制从内存中加载该值。在特定情况下，这两种同步技术的组合可能是必要的，但也会导致显著的性能损失。如果仅使用互斥量就足以保护变量，则省略volatile关键字。

不要为了避免使用互斥对象而使用易失性变量，这一点也很重要。一般来说，互斥锁和其他同步机制比volatile变量更好地保护数据结构的完整性。volatile关键字只确保变量是从内存中加载的，而不是存储在寄存器中。它不能确保您的代码正确地访问变量。
 
### 使用原子操作
非阻塞同步是一种执行某些类型的操作并避免使用锁的方法。尽管锁是同步两个线程的有效方法，但是获取锁是一个相对昂贵的操作，即使在无争用的情况下也是如此。相比之下，许多原子操作只需要一小部分时间就可以完成，并且可以和锁一样有效。

原子操作允许您对32位或64位值执行简单的数学和逻辑操作。这些操作依赖于特殊的硬件指令(和一个可选的内存屏障)，以确保给定的操作在再次访问受影响的内存之前完成。在多线程的情况下，您应该始终使用包含内存屏障的原子操作，以确保线程之间正确地同步内存。

表4-3列出了可用的原子数学和逻辑操作以及对应的函数名。这些函数都在/usr/include/libkern/ osatom .h头文件中声明，您还可以在其中找到完整的语法。这些函数的64位版本仅在64位进程中可用。
 ![IMAGE](/assets/images/resources/9A3F1D924C71902E566CB044746E5C4E.jpg)
 大多数原子函数的行为应该相对简单，正如您所期望的那样。但是，清单4-1显示了原子测试-设置和比较-交换操作的行为，它们稍微复杂一些。对OSAtomicTestAndSet函数的前三个调用演示了如何在整数值上使用位操作公式，其结果可能与您所期望的不同。最后两个调用显示OSAtomicCompareAndSwap32函数的行为。在所有情况下，当没有其他线程操作这些值时，将在无竞争的情况下调用这些函数。
 ![IMAGE](/assets/images/resources/F982967AA79104D32C86AF2F4982FC50.jpg)
有关原子操作的信息，请参阅原子手册页和/usr/include/libkern/ osatom .h头文件。
 
### 使用锁
锁是线程编程的基本同步工具。锁使您能够轻松地保护大块代码，从而确保代码的正确性。OS X和iOS为所有应用程序类型提供了基本的互斥锁，Foundation框架为特殊情况定义了一些额外的互斥锁变体。下面几节将向您展示如何使用这些锁类型中的几种。
  
#### 使用POSIX互斥锁
POSIX互斥锁在任何应用程序中都非常容易使用。要创建互斥锁，需要声明并初始化一个pthread_mutex_t结构体。要锁定和解锁互斥锁，可以使用pthread_mutex_lock和pthread_mutex_unlock函数。清单4-2显示了初始化和使用POSIX线程互斥锁所需的基本代码。当您完成锁的使用时，只需调用pthread_mutex_destroy来释放锁数据结构。
 ![IMAGE](/assets/images/resources/6F15D2CE9F320EC375835A2923E831E8.jpg)
 
#### 使用NSLock类
NSLock对象为Cocoa应用程序实现了一个基本的互斥锁。所有锁(包括NSLock)的接口实际上是由NSLocking协议定义的，该协议定义了锁定和解锁方法。您可以使用这些方法来获取和释放锁，就像使用任何互斥锁一样。

除了标准的锁定行为，NSLock类还添加了tryLock和lockBeforeDate:方法。tryLock方法尝试获取锁，但如果锁不可用，则不会阻塞;相反，该方法只返回NO。lockBeforeDate:方法尝试获取锁，但如果在指定的时间限制内没有获得锁，则解锁线程(并返回NO)。

下面的示例展示了如何使用NSLock对象来协调可视显示的更新，可视显示的数据是由几个线程计算的。如果线程不能立即获得锁，它就会继续计算，直到获得锁并更新显示。
![IMAGE](/assets/images/resources/7B7FA633EE1BE51907495127FB677BA6.jpg)

#### 使用@synchronized指令
@synchronized指令是在Objective-C代码中动态创建互斥锁的一种方便方法。@synchronized指令做了任何其他互斥锁都会做的事情——防止不同的线程同时获得相同的锁。但是，在这种情况下，您不必直接创建互斥量或锁对象。相反，您可以简单地使用任何Objective-C对象作为锁令牌，如下例所示:
![IMAGE](/assets/images/resources/16018069C8AAEFC8708924E5AEAB7C1C.jpg)
传递给@synchronized指令的对象是用于区分受保护块的唯一标识符。如果在两个不同的线程中执行上述方法，在每个线程上为anObj参数传递不同的对象，则每个线程都将获得锁并继续处理，而不会被另一个线程阻塞。但是，如果在这两种情况下传递相同的对象，其中一个线程将首先获得锁，而另一个线程将阻塞，直到第一个线程完成临界区。

作为预防措施，@synchronized块隐式地向受保护的代码添加了一个异常处理程序。这个处理程序在抛出异常时自动释放互斥量。这意味着为了使用@synchronized指令，你还必须在你的代码中启用Objective-C异常处理。如果您不希望隐式异常处理程序引起额外的开销，则应该考虑使用锁类。

有关@synchronized指令的更多信息，请参阅Objective-C编程语言。

### 使用其他Cocoa锁
下面几节描述使用其他几种类型的Cocoa锁的过程。
 
#### 使用NSRecursiveLock对象
NSRecursiveLock类定义了一个锁，该锁可以被同一个线程多次获取，而不会导致线程死锁。递归锁会跟踪成功获取它的次数。每次成功获取锁都必须通过相应的调用来解锁锁。只有当所有的锁和解锁调用都被平衡时，锁才会被真正释放，以便其他线程可以获得它。

顾名思义，这种类型的锁通常用于递归函数内部，以防止递归阻塞线程。在非递归的情况下，也可以类似地使用它来调用语义要求它们也接受锁的函数。下面是一个通过递归获得锁的简单递归函数示例。如果你没有为这段代码使用NSRecursiveLock对象，当再次调用函数时，线程将死锁。
![IMAGE](/assets/images/resources/5C6732F8E3C7FABD871463317908F2AC.jpg)

#### 使用NSConditionLock对象
NSConditionLock对象定义了一个互斥锁，可以用特定的值锁定和解锁。您不应该将这种类型的锁与条件(请参阅条件)混淆。行为有点类似于条件，但实现方式非常不同。

通常，当线程需要以特定顺序执行任务时，例如当一个线程产生数据而另一个线程消耗数据时，您使用NSConditionLock对象。当生产者执行时，消费者使用特定于您的程序的条件来获取锁。(条件本身只是您定义的整数值。)当生产者完成时，它解锁锁，并将锁条件设置为适当的整数值以唤醒消费线程，然后消费线程继续处理数据。

NSConditionLock对象响应的锁定和解锁方法可以在任何组合中使用。例如，你可以将lock消息与unlockWithCondition:配对，或者将lockWhenCondition:消息与unlock配对。当然，后一种组合可以解锁锁，但可能不会释放等待特定条件值的任何线程。

下面的示例展示了如何使用条件锁处理生产者-消费者问题。假设一个应用程序包含一个数据队列。生产者线程向队列中添加数据，消费者线程从队列中提取数据。生产者不需要等待特定的条件，但它必须等待锁可用，以便安全地将数据添加到队列中。
![IMAGE](/assets/images/resources/2D072F691ED509C67554A99A86B166DF.jpg)
因为锁的初始条件被设置为NO_DATA，所以生产者线程在最初获取锁时应该没有问题。它用数据填充队列，并将条件设置为HAS_DATA。在随后的迭代过程中，生产者线程可以在到达时添加新数据，而不管队列是空的还是仍然有一些数据。它只在使用者线程从队列中提取数据时阻塞。

因为使用者线程必须要处理数据，所以它使用特定的条件在队列上等待。当生产者将数据放到队列中时，消费者线程将被唤醒并获取它的锁。然后，它可以从队列中提取一些数据并更新队列状态。下面的示例展示了使用者线程的处理循环的基本结构。
![IMAGE](/assets/images/resources/9F795D46E5766F0F6F8710FB74EE5F95.jpg)

#### 使用NSDistributedLock对象
NSDistributedLock类可以被多台主机上的多个应用程序使用，以限制对某些共享资源(如文件)的访问。锁本身实际上是一个互斥锁，它使用文件系统项(如文件或目录)实现。要使NSDistributedLock对象可用，该锁必须可被所有使用它的应用程序写入。这通常意味着将其放在所有运行应用程序的计算机都可以访问的文件系统上。

不像其他类型的锁，NSDistributedLock不符合NSLocking协议，因此没有锁方法。锁方法将阻塞线程的执行，并要求系统以预定的速率轮询锁。NSDistributedLock提供了一个tryLock方法，让你决定是否轮询，而不是对你的代码施加这种惩罚。

因为它是使用文件系统实现的，所以NSDistributedLock对象不会被释放，除非所有者显式地释放它。如果您的应用程序在持有分布式锁时崩溃，其他客户端将无法访问受保护的资源。在这种情况下，您可以使用breakLock方法来打破现有的锁，以便获取它。但是，通常应该避免破坏锁，除非您确定拥有的进程已经死亡并且无法释放锁。

和其他类型的锁一样，当你用完NSDistributedLock对象时，你通过调用unlock方法释放它。
 
### 使用条件
条件是一种特殊类型的锁，您可以使用它来同步操作必须进行的顺序。它们与互斥锁有微妙的区别。等待某个条件的线程一直处于阻塞状态，直到另一个线程显式地发出该条件的信号。

由于实现操作系统所涉及的微妙之处，即使您的代码没有实际发出信号，也允许条件锁以虚假的成功返回。为了避免这些虚假信号引起的问题，您应该始终将谓词与条件锁结合使用。谓词是一种更具体的方法，用于确定线程继续运行是否安全。该条件只是让线程保持睡眠状态，直到信号线程可以设置谓词。

下面几节将向您展示如何在代码中使用条件。
 
#### 使用NSCondition类
NSCondition类提供了与POSIX条件相同的语义，但是在单个对象中包装了所需的锁和条件数据结构。结果是一个对象，您可以像锁一个互斥量，然后像等待一个条件。

清单4-3展示了等待NSCondition对象的事件序列的代码片段。cocoaCondition变量包含一个NSCondition对象，timeToDoWork变量是一个整数，它是在另一个线程发出条件信号之前递增的。
![IMAGE](/assets/images/resources/8C47CADAFB4301A0EB2C154A154AF956.jpg)

#### 使用POSIX条件
POSIX线程条件锁要求同时使用条件数据结构和互斥量。虽然这两个锁结构是分开的，但互斥锁在运行时紧密地绑定到条件结构。等待信号的线程应该总是同时使用相同的互斥锁和条件结构。更改配对可能会导致错误。

清单4-5显示了条件和谓词的基本初始化和用法。在初始化条件和互斥锁之后，等待线程使用ready_to_go变量作为谓词进入while循环。只有在设置了谓词并随后发出条件信号后，等待线程才会被唤醒并开始工作。
![IMAGE](/assets/images/resources/101581E7537A54DB64AD5F50E462061D.jpg)
信令线程既负责设置谓词，又负责向条件锁发送信号。清单4-6显示了实现此行为的代码。在这个例子中，条件是在互斥锁内部发出信号的，以防止在等待条件的线程之间发生竞争条件。
![IMAGE](/assets/images/resources/1AC6B1C13136443C6F384DA4388AF7C6.jpg)

## 线程安全摘要
本附录描述了OS X和iOS中一些关键框架的高级线程安全。本附录中的信息可能会有所更改。

### Cocoa
在多线程中使用Cocoa的指导方针包括:
不可变对象通常是线程安全的。一旦创建了这些对象，就可以安全地在线程之间传递这些对象。另一方面，可变对象通常不是线程安全的。要在线程应用程序中使用可变对象，应用程序必须进行适当的同步。有关更多信息，请参见可变与不可变。
许多被认为“线程不安全”的对象仅在多线程中使用是不安全的。这些对象中的许多都可以在任何线程中使用，只要每次只有一个线程。专门限制于应用程序主线程的对象就这样被调用。
应用程序的主线程负责处理事件。尽管如果事件路径中涉及其他线程，Application Kit将继续工作，但操作可能不按顺序发生。
如果你想使用线程绘制视图，把所有的绘制代码放在NSView的lockFocusIfCanDraw和unlockFocus方法之间。
要对Cocoa使用POSIX线程，必须首先将Cocoa设置为多线程模式。有关更多信息，请参见在Cocoa应用程序中使用POSIX线程。
 
#### 基础框架线程安全
有一种误解，认为Foundation框架是线程安全的，而Application Kit框架不是。不幸的是，这是一个笼统的概括，有些误导。每个框架都有线程安全的区域和非线程安全的区域。下面几节描述Foundation框架的一般线程安全性。
![IMAGE](/assets/images/resources/24613E06A9751C680A4AF727789BAB70.jpg)
![IMAGE](/assets/images/resources/86089F35990385E66D4E62AD6E7A3D6B.jpg)

#### 仅主线程类
下面的类只能在应用程序的主线程中使用。
`NSAppleScript`
#### 可变与不可变
不可变对象通常是线程安全的;一旦创建了这些对象，就可以安全地在线程之间传递这些对象。当然，在使用不可变对象时，仍然需要记住正确使用引用计数。如果您不恰当地释放了您没有保留的对象，那么稍后可能会导致异常。

可变对象通常不是线程安全的。要在线程应用程序中使用可变对象，应用程序必须使用锁同步对它们的访问。(有关更多信息，请参见原子操作)。一般来说，当涉及到突变时，集合类(例如NSMutableArray, NSMutableDictionary)不是线程安全的。也就是说，如果一个或多个线程正在更改同一个数组，就会出现问题。必须锁定发生读写的位置，以确保线程安全。

即使一个方法声称要返回一个不可变的对象，也不应该简单地假设返回的对象是不可变的。根据方法实现的不同，返回的对象可能是可变的，也可能是不可变的。例如，一个返回类型为NSString的方法，由于它的实现，实际上可能返回一个NSMutableString。如果你想保证你拥有的对象是不可变的，你应该创建一个不可变的副本。
 
#### 可重入性
只有当操作“调用”到同一对象或不同对象上的其他操作时，才可能实现重入。保留和释放对象就是这样一种有时被忽视的“调出”。

下表列出了Foundation框架中显式可重入的部分。所有其他类都可能是可重入的，也可能不是，或者它们将来可能是可重入的。对可重入性的完整分析从来没有做过，这个列表可能不是详尽的。
 ![IMAGE](/assets/images/resources/57AE0F4E4B29CD3E36C009B1B95B3D6A.jpg)
 
#### 类初始化
Objective-C运行时系统在类接收任何其他消息之前向每个类对象发送初始化消息。这使类在使用之前有机会设置其运行时环境。在多线程应用程序中，运行时保证只有一个线程(恰好向类发送第一个消息的线程)执行initialize方法。如果第二个线程试图向该类发送消息，而第一个线程仍在initialize方法中，则第二个线程将阻塞，直到initialize方法执行完毕。同时，第一个线程可以继续调用类上的其他方法。初始化方法不应该依赖于类的第二个线程调用方法;如果是这样，两个线程就会发生死锁。

由于OS X 10.1版本的bug。X和更早的时候，线程可以在另一个线程完成执行类的initialize方法之前向类发送消息。然后，线程可以访问尚未完全初始化的值，这可能会导致应用程序崩溃。如果遇到此问题，则需要引入锁以防止在初始化值之前访问这些值，或者强制类在成为多线程之前初始化自身。

#### 自动释放池
每个线程维护自己的NSAutoreleasePool对象堆栈。Cocoa期望在当前线程的堆栈上有一个自动释放池总是可用的。如果池不可用，则不会释放对象，从而导致内存泄漏。NSAutoreleasePool对象是在应用程序的主线程中基于Application Kit自动创建和销毁的，但是辅助线程(以及仅基于foundation的应用程序)在使用Cocoa之前必须创建自己的对象。如果你的线程是长期存在的，并且可能会生成大量的自动释放对象，你应该定期销毁并创建自动释放池(就像Application Kit在主线程上所做的那样);否则，自动释放的对象会累积，内存占用会增加。如果分离的线程不使用Cocoa，则不需要创建自动释放池。
 
#### 运行循环
每个线程有且只有一个运行循环。但是，每个运行循环，因此每个线程都有自己的一组输入模式，这些模式决定在运行运行循环时侦听哪些输入源。在一个运行循环中定义的输入模式不会影响在另一个运行循环中定义的输入模式，即使它们可能具有相同的名称。

如果应用程序基于application Kit，则主线程的运行循环将自动运行，但辅助线程(以及仅基于foundation的应用程序)必须自己运行运行循环。如果被分离的线程没有进入运行循环，那么一旦被分离的方法完成执行，线程就会退出。

尽管有一些外观，NSRunLoop类不是线程安全的。您应该只从拥有该类的线程调用该类的实例方法。

### 应用程序工具包框架线程安全
下面几节描述Application Kit框架的一般线程安全性。
#### 线程不安全的类
下面的类和函数通常不是线程安全的。在大多数情况下，您可以在任何线程中使用这些类，只要一次只能在一个线程中使用它们。查看类文档了解更多细节。
![IMAGE](/assets/images/resources/EB142C776CDD178445867F9FC45CD2A7.jpg)
#### 仅主线程类
以下类只能在应用程序的主线程中使用。
![IMAGE](/assets/images/resources/22E405AE6E01B1948E8FCAC7A2F227B3.jpg)

#### 窗口的限制
您可以在次要线程上创建窗口。Application Kit确保与窗口关联的数据结构在主线程上被释放，以避免竞争条件。在并发处理大量窗口的应用程序中，窗口对象可能会泄漏。

你可以在次要线程上创建一个模态窗口。Application Kit在主线程运行模态循环时阻塞调用辅助线程。

#### 事件处理限制
应用程序的主线程负责处理事件。主线程是NSApplication的run方法中阻塞的线程，通常在应用程序的main函数中调用。如果事件路径中涉及其他线程，则Application Kit继续工作，但操作可能不按顺序发生。例如，如果两个不同的线程正在响应键事件，则键的接收顺序可能是乱的。通过让主线程处理事件，您可以获得更加一致的用户体验。一旦接收到事件，如果需要，可以将事件分派到次要线程进行进一步处理。

你可以在辅助线程中调用NSApplication的postEvent:atStart:方法来发布一个事件到主线程的事件队列中。但是，对于用户输入事件，不能保证顺序。应用程序的主线程仍然负责处理事件队列中的事件。
 
#### 绘制的限制
当使用它的图形函数和类(包括NSBezierPath和NSString类)绘制时，Application Kit通常是线程安全的。下面几节描述了使用特定类的详细信息。关于绘图和线程的其他信息可在Cocoa绘图指南中获得。

##### NSView限制
NSView类通常不是线程安全的。只能在应用程序的主线程中对NSView对象进行创建、销毁、调整大小、移动和其他操作。从次要线程绘图是线程安全的，只要你用对lockFocusIfCanDraw和unlockFocus的调用作为括号。

如果应用程序的辅助线程想要在主线程上重绘视图的部分，它不能使用display、setNeedsDisplay:、setNeedsDisplayInRect:或setViewsNeedDisplay:这样的方法。相反，它应该向主线程发送一条消息，或者使用performSelectorOnMainThread:withObject:waitUntilDone:方法来调用这些方法。

视图系统的图形状态(gstates)是每个线程的。使用图形状态曾经是在单线程应用程序上实现更好的绘图性能的一种方法，但现在已经不再是这样了。不正确地使用图形状态实际上会导致绘图代码比在主线程中绘图效率更低。

##### NSGraphicsContext限制
NSGraphicsContext类表示底层图形系统提供的绘图上下文。每个NSGraphicsContext实例都拥有自己独立的图形状态:坐标系统、剪切、当前字体等等。在主线程上为每个NSWindow实例自动创建类的实例。如果你从一个次要线程中进行任何绘制，一个新的NSGraphicsContext实例会专门为那个线程创建。

如果从辅助线程进行任何绘图，则必须手动刷新绘图调用。Cocoa不会自动更新从次要线程绘制的内容的视图，所以当你完成绘制时，你需要调用NSGraphicsContext的flushGraphics方法。如果应用程序只从主线程绘制内容，则不需要刷新绘图调用。

##### NSImage限制
一个线程可以创建一个NSImage对象，绘制到图像缓冲区，并将其传递给主线程进行绘制。底层图像缓存在所有线程之间共享。有关图像和缓存工作原理的更多信息，请参阅Cocoa Drawing Guide。

### Core Data框架
Core Data框架通常支持线程，尽管有一些使用注意事项。有关这些警告的信息，请参阅核心数据编程指南中的核心数据并发。

### Core Foundation
Core Foundation是足够线程安全的，如果您小心编程，就不会遇到与竞争线程相关的任何问题。在常见情况下，例如查询、保留、释放和传递不可变对象时，它是线程安全的。即使是从多个线程查询的中心共享对象也是可靠的线程安全的。

像Cocoa一样，当涉及到对象或其内容的突变时，Core Foundation也不是线程安全的。例如，如您所料，修改可变数据或可变数组对象不是线程安全的，但在不可变数组中修改对象也是如此。原因之一是性能，这在这些情况下是至关重要的。此外，通常不可能在这个级别上实现绝对的线程安全。例如，您不能排除由于保留从集合获得的对象而导致的不确定行为。在调用保留包含的对象之前，可以释放集合本身。

在Core Foundation对象将从多个线程访问并发生变化的情况下，您的代码应该通过在访问点上使用锁来防止同时访问。例如，枚举Core Foundation数组对象的代码应该在枚举块周围使用适当的锁定调用，以防止其他人对数组进行更改。

* 引用: 
1. https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091-CH1-SW1
2. https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i
