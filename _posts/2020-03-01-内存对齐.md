---
layout: post
title: 内存对齐
subtitle: 内存对齐的思考
categories: 基础
tags: [内存]
---
# 1.什么是内存对齐？
只针对聚合类型的数据。比如结构体，联合体，类。这里采用结构体来说明。
想象中结构体中的内存是每个字节都存储的有数据，即是每个存储在内存中的数据都是紧挨着的。但实际上一般情况并不是紧挨着存储的。这种采用一定规则排序内存的方式叫做内存对齐。
# 2.内存对齐是怎么做的？
既然叫做内存对齐，必然有一个问题，比如按4字节对齐，或者8字节对齐。那么这个数字就叫做

**有效对齐值**

有效对齐值是怎么计算的？
每个结构体的有效对齐值是一样的吗？

**计算有效对齐值**

1.平台默认对齐值
 每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。你可以通过预编译命令
` #pragma pack(show)`
来查看默认对齐系数，一般的默认对齐系数为8。

2.结构体的对齐值
结构体的对齐值为结构体中数据类型最大占用的字节数。比如结构体中最大的类型为int占用4个字节。则此结构体的对齐值为4。如果结构体中最大的类型为double占用8个字节。则次结构体的对齐值为8。

* 有效对齐值即是平台默认对齐值和结构体对齐值中较小的那个数作为有效对齐值。
比如:
```
struct s1{
  char a;
  short b;
  int c;
};
struct s2{
  char a;
  int b;
  double c;
};
```
假设采用平台默认对齐值为8，而结构体s1中最大的数据类型为int占4个字节。则结构体s1的有效对齐值为8和4中较小的数。即s1的有效对齐值为4。同理结构体s2的有效对齐值为8。
**结构体的内存布局规则**

  **1.** 结构体变量的首地址是有效对齐值的整数倍。
  
  **2.** 结构体第一个成员的偏移量（offset）为0,以后每个结构体成员相对于结构体首地址的偏移量都是该成员大小和有效对齐值中较小的数的整数倍。
  
  **3.** 结构体的总大小为有效对齐值的整数倍。如有需要，编译器会为最末一个成员的末尾加上填充字节。
  
**平台默认对齐值为8的情况**
此时结构体s1的有效对齐值为4，结构体s2的有效对齐值为8
  ![IMAGE](/assets/images/resources/9EE8D3C634B88391DB900EEE89DAA318.jpg)
  分析结构体s1类型的temp1
  **有效对齐值**
  平台默认对齐值为8，s1中最大的数据类型为int占4个字节。故s1的有效对齐值为4
 
  **规则1：**
   **起始地址**的规则
  可以看到temp1的起始地址是有效对齐值4的整数倍。满足规则1。这里为了方便我们假设起始地址为0x0

  **规则2：**
   **每个成员相对于首地址的偏移量**的规则
  char a; 首个成员变量的偏移量为0。char类型占一个字节，则0x0这个字节存储的为a;此时下一个连续的地址为0x1;
  short b; short类型占2个字节，有效对齐值为4,则成员变量b的偏移量要为较小数2的倍数。显然0x1不为2的倍数。故b的偏移量为0x2才满足规则2。故0x2-0x3这两个字节存储成员b,下一个连续的地址为0x4;
  int c; int类型占4个字节，有效对齐值为4。则较小值为4，成员变量c相对于首地址的偏移量为4的倍数即可。0x4刚好是4的倍数。则0x4-0x7存储成员变量c的值;
 
  **规则3：**
   **结构体的大小**规则
  此时0x0-0x7中共8个字节存储了s1结构体所有成员变量的值。大小为8。看规则3。8刚好为有效对齐值4的整数倍。满足规则3。故结构体s1所占的大小为8个字节。
  
**平台默认对齐值为1的情况**
此时结构体s1和s2的有效对齐值均为1
 ![IMAGE](/assets/images/resources/82DCD1A714CC19DA11DDDD5962D1BF30.jpg)
此处内存布局分析同上。

# 3.为什么要内存对齐
  **性能**
  cpu对内存的读取是一次读取一块内存 并不是一次读取一个字节
  
  程序的运行实际上就是cpu不断的从内存中读取数据，指令进行运算。减少cpu读取内存的次数可以减少程序运行完成所消耗的时间，比如假设cpu一次读取4个字节，如果不进行内存对齐，cpu读取起始地址为0x001上存取的一个int类型的数据，需要先读取0x000到0x003 一共4个字节，然后在读取0x004到0x007一共4个字节，在组合0x001到0x004才能得到一个int类型的数据，显然不如读取一个存储起始地址为0x000上的int数据快。
  **平台**
  各个硬件平台对存储空间的处理不同，不是所有的硬件平台都能访问任意地址上的任意数据。 某些硬件平台只能 在某 些特定地址处取某些特定类型的数据，否则会抛出硬件异常。

# 扩展
1.非聚合类型的数据对齐。
单个数据类型。只和数据起始地址有关，起始地址满足是数据类型大小的整数倍即可。
2.#pragma pack(number) number是2^n次方
指定聚合类型数据的对齐方式，

malloc,calloc,realloc
## malloc

malloc函数可以从堆上获得指定字节的内存空间，其函数声明如下：

void * malloc(int n);

其中，形参n为要求分配的字节数。如果函数执行成功，malloc返回获得内存空间的首地址；如果函数执行失败，那么返回值为NULL。由于malloc函数值的类型为void型指针，因此，可以将其值类型转换后赋给任意类型指针，这样就可以通过操作该类型指针来操作从堆上获得的内存空间。
需要注意的是,malloc函数分配得到的内存空间是未初始化的。因此，一般在使用该内存空间时，要调用另一个函数memset来将其初始化为全0。memset函数的声明如下：
void * memset (void * p,int c,int n) ;
该函数可以将指定的内存空间按字节单位置为指定的字符c。其中，p为要清零的内存空间的首地址，c为要设定的值，n为被操作的内存空间的字节长度。如果要用memset清0，变量c实参要为0。malloc函数和memset函数的操作语句一般如下：

## calloc
calloc函数的功能与malloc函数的功能相似，都是从堆分配内存。其函数声明如下：

void *calloc(int n,int size);

函数返回值为void型指针。如果执行成功，函数从堆上获得size X n的字节空间，并返回该空间的首地址。如果执行失败，函数返回NULL。该函数与malloc函数的一个显著不同时是，calloc函数得到的内存空间是经过初始化的，其内容全为0。calloc函数适合为数组申请空间，可以将size设置为数组元素的空间长度，将n设置为数组的容量。

## realloc
realloc函数的功能比malloc函数和calloc函数的功能更为丰富，可以实现内存分配和内存释放的功能，其函数声明如下：

void * realloc(void * p,int n);

![IMAGE](/assets/images/resources/AAD689F1ED1A391DE246EAC870E97149.jpg)

其中，指针p必须为指向堆内存空间的指针，即由malloc函数、calloc函数或realloc函数分配空间的指针。realloc函数将指针p指向的内存块的大小改变为n字节。如果n小于或等于p之前指向的空间大小，那么。保持原有状态不变。如果n大于原来p之前指向的空间大小，那么，系统将重新为p从堆上分配一块大小为n的内存空间，同时，将原来指向空间的内容依次复制到新的内存空间上，p之前指向的空间被释放。relloc函数分配的空间也是未初始化的。

注意：使用malloc函数，calloc函数和realloc函数分配的内存空间都要使用free函数或指针参数为NULL的realloc函数来释放。



什么是字节序
字节序指的是多字节的数据各字节的存储顺序。根据存储顺序的不同又分为大端序和小端序
比如16进制0x01234567在地址0x01,0x02,0x03,0x04存储的分别是01，23，45，67。低地址存储高位则表示是大端序，反之是小端序。即高位在前是大端序，反之是小端序。


1.起始地址的对齐
![IMAGE](/assets/images/resources/34C0DF14C46E87B441F533E3B3ECB407.jpg)
申请一块内存的起始地址在32位机器上是8字节对齐即起始地址为8的倍数即0xnnnnnnn0或者0xnnnnnnn8。其中n为0到F的取值。同理在64位机器上是16字节对齐。即起始地址为16的倍数即地址为0xnnnnnnnnnnnnnnn0。
